module sdf2imp/project/create-runtime-libraries

imports
  sdf2imp/util/-

strategies
  
	create-analysis-analysis = 
		<output-text-file(|["lib", "runtime", "analysis"], "analysis.str")>
"module runtime/analysis/analysis

imports
	
	libstratego-lib
	
	runtime/analysis/-
	runtime/index/-
	runtime/nabl/-
	runtime/properties/-
	runtime/relations/-
	runtime/task/-
	runtime/types/-

"

	create-analysis-builtins = 
		<output-text-file(|["lib", "runtime", "analysis"], "builtins.str")>
"module runtime/analysis/builtins

imports
	
	runtime/analysis/single
	runtime/analysis/interface
	
rules

	analysis-analyze-builtin-partitions(collector|language, project-path) =
		analysis-get-builtin-partitions; map(analysis-analyze-builtin-partition(collector|language, project-path))	

	analysis-get-builtin-partitions =
		analysis-builtin-partitions <+ ![]

	analysis-analyze-builtin-partition(collector|language, project-path):
		(path, ast) -> analyzed-ast
		with
	    (
	    	analyzed-ast
			, (analysis-error*, analysis-warning*, analysis-note*)
			, removed-entry-count
			, added-entry-count
			, removed-task-count
			, added-task-count
			, invalidated-task-count
			, evaluated-task*
			, skipped-task*
			, unevaluated-task*
			) := <analyze-one(collector|language, path, project-path)> ast

"

	create-analysis-complete = 
		<output-text-file(|["lib", "runtime", "analysis"], "complete.str")>
"module runtime/analysis/complete

imports
	
	runtime/nabl/complete
	runtime/task/core
	runtime/index/core
	
rules
	
	analysis-propose-completions(|language, project-path):
		ast -> <nabl-propose-completions> ast
		with
    	task-setup(|project-path);
    	index-setup(|language, project-path)

	// Legacy
	analysis-propose-completions(|language, project-path, path) = analysis-propose-completions(|language, project-path)

"

	create-analysis-core = 
		<output-text-file(|["lib", "runtime", "analysis"], "core.str")>
"module runtime/analysis/core

imports
	
  runtime/analysis/interface
  runtime/index/core
  runtime/nabl/collect
  runtime/nabl/incremental
  runtime/nabl/entries
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/task/core
  runtime/task/messages
  runtime/relations/incremental
  runtime/editor/origins
  
signature

  constructors
  
    File : Path * Term -> File
    File : Path * Term * Term -> File
    
    // Result(partition, initial-ast, analyzed-ast, changed-read*, error*, warning*, note*)
    Result      : Partition * AST * AST * List(URI) * List(Term) * List(Term) * List(Term) -> Result
    
    // DebugResult(removed-entry*, added-entry*, removed-task*, added-task*, invalidated-task*)
    DebugResult : List(Entry) * List(Entry) * List(TaskID) * List(TaskID) * List(TaskID) -> Result
    
rules // Analysis
	
	// analyze-collect(|language, project-path) = analyze-collect(nabl-collect, id|language, project-path)
	analyze-collect(collector|language, project-path) = analyze-collect(collector, id|language, project-path)
	analyze-collect(collector, try-recover|language, project-path):
    File(partition, initial-ast, transformed-ast) -> ( 
    	Result(partition, initial-ast, analyzed-ast, changed-read*, [], [], [])
    , DebugResult(<length> removed-entry*, <length> added-entry*, <length> removed-task*, <length> added-task*, <length> invalidated-task*)
  	)
    with
    	<analysis-core-debug(!\"Collecting: \")> partition;
    	measure-time(
	    	measure-time(
	    		index-setup(|language, project-path);
	    		try(try-recover; index-recover);
			    index-start-collection(|partition);
	    		task-setup(|project-path);
	    		try(try-recover; task-recover);
	    		task-start-collection(|partition)
	      	, analysis-core-debug-time(!\"Time - setup: \") | \"analyze-collect-setup\"
	      ); measure-time(
	      	analyzed-ast := <collector(id|Language(language), partition, <new-hashtable>, [])> transformed-ast
	    	  , analysis-core-debug-time(!\"Time - collect: \") | \"analyze-collect-collect\" 
	  	  ); measure-time(
	  	  	index-stop-collection            => (removed-entry*, added-entry*);
	      	task-stop-collection(|partition) => (removed-task*, added-task*);
	      	
	      	change*            := [removed-entry*, added-entry*];
	      	nabl-changed-read* := <nabl-get-changed-reads> change*;
	      	rel-changed-read*  := <relation-get-changed-reads> change*;
	      	changed-read*      := [nabl-changed-read*, rel-changed-read*]
	      	, analysis-core-debug-time(!\"Time - diff: \") | \"analyze-collect-diff\" 
	  	  ); measure-time(
	  	  	task-invalidate-task-reads(|changed-read*) => invalidated-task*
	  	  	, analysis-core-debug-time(!\"Time - invalidate: \") | \"analyze-collect-invalidate\"
	  	  )
  	  , id | \"analyze-collect-total\")
	
	analyze-perform-all:
		result* -> (result'*, evaluated-task*, skipped-task*, unevaluated-task*)
		with
			measure-time(
				measure-time(
	      	task-evaluate-scheduled => (evaluated-task*, skipped-task*, unevaluated-task*)
	      	, analysis-core-debug-time(!\"Time - evaluation: \") | \"analyze-task-evaluate\"
	      ); measure-time(
	  	  	result'* := <map(analyze-messages)> result*
	  	  	, analysis-core-debug-time(!\"Time - messages: \") | \"analyze-task-messages\"
	  	  )
  	, id | \"analyze-task-total\")
  	  
  analyze-messages:
  	(Result(partition, initial-ast, analyzed-ast, changed-read*, _, _, _), debug-result) -> 
  	(Result(partition, initial-ast, analyzed-ast, changed-read*, error*, warning*, note*), debug-result)
  	with
			(error*, warning*, note*) := <analyze-get-messages> partition

	analyze-get-messages:
		partition -> (error*, warning*, note*)
		with
  		message* := <task-get-messages(|partition)>;
  		error*   := <filter(?Error(_, _, _); analyze-message-to-tuple)> message*;
  		warning* := <filter(?Warning(_, _, _); analyze-message-to-tuple)> message*;
  		note*    := <filter(?Note(_, _, _); analyze-message-to-tuple)> message*
  		
	analyze-message-to-tuple:
		message -> (<origin-location-offset-set(|origin)> term, msg)
		with
			origin := <task-message-origin> message;
			term   := <task-message-term> message;
			msg    := <task-message> message
      
rules // Projections
	
	analyze-result-reads:
		Result(_, _, _, changed-read*, _, _, _) -> changed-read*
		
	analyze-result-analyzed-ast:
		Result(_, _, analyzed-ast, _, _, _, _) -> analyzed-ast

	analysis-partition(|path, project-path) = !$[[project-path]/[path]]

rules // Debugging
	
	analysis-core-debug(msg) = try(analysis-core-debug-interface(msg))
	analysis-core-debug = try(analysis-core-debug-interface)
	analysis-core-debug-interface(msg) = fail
	analysis-core-debug-interface = fail
	
	analysis-core-debug-time(msg) = try(analysis-core-debug-time-interface(msg))
	analysis-core-debug-time = try(analysis-core-debug-time-interface)
	analysis-core-debug-time-interface(msg) = fail
	analysis-core-debug-time-interface = fail
	

"

	create-analysis-debug = 
		<output-text-file(|["lib", "runtime", "analysis"], "debug.str")>
"module runtime/analysis/debug

imports
	
	runtime/index/core
	runtime/index/query
	runtime/task/core
	runtime/task/debug
	runtime/task/insert
	runtime/editor/interop
	runtime/nabl/entries
	runtime/nabl/uri

rules // Index
	 
	analysis-debug-show-all-partitions(|language) = analysis-debug-index-project(|language)
	analysis-debug-show-current-partition(|language) = analysis-debug-index-partition(|language)
	 
  analysis-debug-index-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      result-ast := <index-get-all-partitions; map(\\f -> (f, <index-get-all-in-partition> f)\\)>;
      if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast then
      	filename := $[[project-path]/[<dirname> path]/project.index];
      	result   := result-index
      else
      	filename := $[[project-path]/[<dirname> path]/index.project.aterm];
      	result   := result-ast
    	end
    	
  analysis-debug-index-project-resolve(|language):
	(_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      task-setup(|project-path);
      result-ast := <index-get-all-partitions; map(\\f -> (f, <index-get-all-in-partition> f)\\)>;
      result-ast' := <beautify-indices> result-ast;
	  if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast' then
		filename := $[[project-path]/[<dirname> path]/project.index];
		result   := result-index
	  else
		filename := $[[project-path]/[<dirname> path]/index.project.aterm];
		result   := result-ast'
	  end
	 
  analysis-debug-index-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
    	partition  := $[[project-path]/[path]];
      result-ast := [(partition, <index-get-all-in-partition> partition)];
      if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast then
      	filename := <guarantee-extension(|\"partition.index\")> path;
      	result   := result-index
      else
      	filename := <guarantee-extension(|\"index.partition.aterm\")> path;
      	result   := result-ast
    	end
    	
  analysis-debug-index-partition-resolve(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      task-setup(|project-path);
    	partition  := $[[project-path]/[path]];
      result-ast := [((partition, []), <index-get-all-in-partition> partition)];
      result-ast' := <beautify-indices> result-ast;
      if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast' then
      	filename := <guarantee-extension(|\"partition.index\")> path;
      	result   := result-index
      else
      	filename := <guarantee-extension(|\"index.partition.aterm\")> path;
      	result   := result-ast'
    	end
  
rules // Task engine    
      
  analysis-debug-show-tasks(|language) = analysis-debug-task-partition(|language)
  analysis-debug-show-tasks-selection(|language) = analysis-debug-task-selection(|language)

  analysis-debug-task-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
      result-ast := <task-debug-info(|())>;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
      	filename := $[[project-path]/[<dirname> path]/project.task];
      	result   := result-task
      else
      	filename := $[[project-path]/[<dirname> path]/task.project.aterm];
      	result   := result-ast
    	end
      
  analysis-debug-task-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
    	partition  := $[[project-path]/[path]];
      result-ast := <task-debug-info(|partition)>;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
      	filename := <guarantee-extension(|\"partition.task\")> path;
      	result   := result-task
      else
      	filename := <guarantee-extension(|\"task.partition.aterm\")> path;
      	result   := result-ast
    	end
      
  analysis-debug-task-selection(|language):
    (selected, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
    	partition  := $[[project-path]/[path]];
      result-ast := <task-debug-ast> selected;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
      	filename := <guarantee-extension(|\"selection.task\")> path;
      	result   := result-task
      else
      	filename := <guarantee-extension(|\"task.selection.aterm\")> path;
      	result   := result-ast
    	end
    	
rules // Index & task engine
	
  analysis-debug-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
    	index-setup(|language, project-path);
      task-setup(|project-path);
      task-debug  := <task-debug-info(|())>;
      index-debug := <index-get-all-partitions; map(\\f -> (f, <index-get-all-in-partition; sort-index> f)\\)>;
      result-ast  := (task-debug, index-debug);
      if result-analysis := <foreign-call(|\"Analysis\", \"from-debug-str\")> result-ast then
      	filename := $[[project-path]/[<dirname> path]/project.analysis];
      	result   := result-analysis
      else
      	filename := $[[project-path]/[<dirname> path]/analysis.project.aterm];
      	result   := result-ast
    	end
    	
  analysis-debug-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
    	index-setup(|language, project-path);
      task-setup(|project-path);
      partition   := $[[project-path]/[path]];
      task-debug  := <task-debug-info(|partition)>;
      index-debug := [(partition, <index-get-all-in-partition; sort-index> partition)];
      result-ast  := (task-debug, index-debug);
      if result-analysis := <foreign-call(|\"Analysis\", \"from-debug-str\")> result-ast then
      	filename := <guarantee-extension(|\"partition.analysis\")> path;
      	result   := result-analysis
      else
      	filename := <guarantee-extension(|\"partition.aterm\")> path;
      	result   := result-ast
    	end
   
rules // Resetting  
      
  analysis-debug-reset-index(|language):
    (_, _, _, path, project-path) -> None()
    with
    	partition := $[[project-path]/[path]];
      index-setup(|language, project-path);
      index-reset
      
  analysis-debug-reset-task(|language):
    (_, _, _, path, project-path) -> None()
    with
      task-setup(|project-path);
      task-reset

  analysis-debug-reanalyze(|language):
    (_, _, _, path, project-path) -> None()
    with
    	partition := $[[project-path]/[path]];
    	task-setup(|project-path);
    	task-reset;
      index-setup(|language, project-path);
      index-reload

rules // Helper rules for Index Resolved

	beautify-indices: indices -> indices''
		where
			indices'  := <filter(ignore-extension)> indices;
			indices'' := <map(beautify-index)>indices'
		
	beautify-index: (partition, index) -> (partition, index4)
		where
			index2 := <give-all-tasks-results>index;
			index3 := <reverse-uris> index2;
			index4 := <sort-index> index3

	// ignore partitions of generated files
	ignore-extensions: _ -> [\"index\", \"analysis\", \"task\"]
	ignore-extension: (partition, index) -> (partition, index)
		where
			(path, _) := partition;
			extension := <get-extension>path;
			<not(elem)> (extension, <ignore-extensions>)
	
	// resolve all task results
	give-all-tasks-results = bottomup(try(give-task-results))
	give-task-results: e@Result(_) -> <insert-results-or-delay <+ with(fail|\"Task has no result yet: \")>e
	
	sort-index = qsort(index-compare)
	
	// order the index entries
	index-ordering: _ -> [\"Def\",\"Prop\",\"RelTuple\",\"Alias\",\"InverseAlias\",\"Use\"]

	index-compare: (a,b) -> (a,b)
		where
			a-order := <get-index> (<get-constructor>a, <index-ordering>);
			b-order := <get-index> (<get-constructor>b, <index-ordering>);
			if <eq>(a-order, b-order) then
				if Use(_) := a then
					Use([Def(URI(_, a-url))]) := a;
					Use([Def(URI(_, b-url))]) := b
				else
					[URI(_, a-url)|_] := <get-arguments>a;
					[URI(_, b-url)|_] := <get-arguments>b
				end;
				<uri-compare> (a-url, b-url)
			else
				cmp-o := <lt>(a-order, b-order)
			end
	
	uri-compare: ([], []) -> <fail>
	uri-compare: (a, []) -> <fail>
	uri-compare: ([], b) -> ([], b)
	uri-compare: ([a|as], [b|bs]) -> ([a|as], [b|bs]) 
		where
			ID(a-namespace, a-name, _) := a;
			ID(b-namespace, b-name, _) := b;
			if <eq>(a-namespace, b-namespace) then
				if <eq>(a-name, b-name) then
					<uri-compare> (as, bs)
				else
					<string-lt>(a-name, b-name)
				end
			else
				<string-lt>(<get-constructor>a-namespace, <get-constructor>b-namespace)
			end
			
	// reverse URIs (for having urls in the right order, and for ordering as tree)
	reverse-uris = bottomup(try(reverse-uri))
	reverse-uri: URI(language, uri) -> URI(language, <reverse>uri)

"

	create-analysis-defaults = 
		<output-text-file(|["lib", "runtime", "analysis"], "defaults.str")>
"module runtime/analysis/defaults

imports
	
	runtime/analysis/core
	runtime/analysis/single
	runtime/analysis/multiple
	runtime/analysis/builtins
	runtime/analysis/interface
	runtime/nabl/collect
	runtime/nabl/uri
	runtime/nabl/utils
	runtime/index/core
	runtime/task/core
	runtime/editor/editor
	runtime/editor/queue
	runtime/editor/dynrule

rules // Analysis
	
	analysis-default-editor = analysis-single-default-interface <+ (where(not(is-tuple)); analysis-multiple-default-queue)
	analysis-default-cmd = analysis-single-default-interface <+ (where(not(is-tuple)); analysis-multiple-default-interface)

  analysis-changed-sources:
  	task-id* -> <task-sources-of(|task-id*)>
  	
  is-test-file = 
    string-ends-with(|\".spt\")

rules // Single finle analysis
	
	analysis-single-default-interface = fail
	
	analysis-single-default(desugar-before, desugar-after, pp-message|language) = 
		analysis-single-default(desugar-before, nabl-collect, desugar-after, pp-message|language)
  analysis-single-default(desugar-before, collector, desugar-after, pp-message|language):
    (ast, path, project-path) -> (analyzed-ast', error*, warning*, note*)
    with
      editor-init
		with
      analysis-analyze-builtin-partitions(collector|language, project-path)
    with
      <analysis-default-debug(!\"Analyzing file: \")> path;
      partition := <analysis-partition(|path, project-path)>;
      
      transformed-ast := <analysis-pre-trans <+ desugar-before> ast;
	    (
	    	analyzed-ast
			, (analysis-error*, analysis-warning*, analysis-note*)
			, removed-entry-count
			, added-entry-count
			, removed-task-count
			, added-task-count
			, invalidated-task-count
			, evaluated-task*
			, skipped-task*
			, unevaluated-task*
			) := <analyze-one(collector|language, path, project-path)> (ast, transformed-ast);
			analyzed-ast' := <analysis-post-trans(|partition) <+ desugar-after> analyzed-ast;
			
      (error*, warning*, note*) := <analysis-message-collect(pp-message|analysis-error*, analysis-warning*, analysis-note*)> analyzed-ast';
      
      partition* := <analysis-changed-sources; filter(is-string)> evaluated-task*;
      if <not(is-test-file)> path then
      	<remove-all(?partition <+ ?path); analysis-message-update-partitions-queue(|language, project-path)> partition*
    	end;
    	
    	<analysis-debug-results> (removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count, evaluated-task*, skipped-task*, unevaluated-task*)
      
rules // Multi-file analysis
      
  analysis-multiple-default-interface = fail    
      
	analysis-multiple-default-queue:
    path* -> None()
    with
      queue-strategy(|\"analysis-multiple-default-interface\", \"Analyzing files\")
  
  analysis-multiple-default(parse, desugar-before, desugar-after, pp-message|language, project-path) = 
		analysis-multiple-default(parse, desugar-before, nabl-collect, desugar-after, pp-message|language, project-path)    
  analysis-multiple-default(parse, desugar-before, collector, desugar-after, pp-message|language, project-path):
    path* -> (
      analysis-message-result*
    , (removed-entry-count, added-entry-count)
    , (removed-task-count, added-task-count, invalidated-task-count, evaluated-task*, skipped-task*, unevaluated-task*)
    , (parse-time, pre-trans-time, collect-time, perform-time, post-trans-time, index-persist-time, task-persist-time)
    )
    with
    	analysis-analyze-builtin-partitions(collector|language, project-path)
    with
    	analysis-default-debug(!\"Analyzing files: \");
      analysis-multiple-default-work-units; set-total-work-units;
      
      measure-time(
	      measure-time(
	      	path'* := <map(\\p -> $[[project-path]/[p]]\\)> path*;
	        ((result*, evaluated-task*, skipped-task*, unevaluated-task*), parse-time, pre-trans-time, collect-time, perform-time) := 
	        	<analyze-multiple(parse, (analysis-pre-trans <+ desugar-before), complete-work-unit, collector|language, project-path)> path'*;
	        (analysis-result*, debug-result*) := <unzip> result*
	      , analysis-default-debug-time(!\"Time - analysis: \") | \"analysis-multiple-full-analysis\"
	      );
	      measure-time(
	      	analysis-desugared-result* := <filter(analysis-desugar-after(desugar-after))> analysis-result*
	      , analysis-default-debug-time(!\"Time - post analysis transformations: \"), ?post-trans-time | \"analysis-multiple-post-trans\" 
	      );
	      measure-time(
	      	analysis-message-result* := <filter(analysis-update-editor(desugar-after, pp-message))> analysis-desugared-result*
	      	// TODO: Update markers for partitions that have had a task executed but were not analyzed.
	      , analysis-default-debug-time(!\"Time - messages: \") | \"analysis-multiple-update-editors\"
	      );
	    	(
	    		(analysis-disable-persist; index-persist-time := 0.0; task-persist-time := 0.0) <+
	    		(
			    	measure-time(
				      index-persist
			      , analysis-default-debug-time(!\"Time - index persistance: \"), ?index-persist-time | \"analysis-multiple-index-persist\"
			      );
			    	measure-time(
				      task-persist
			      , analysis-default-debug-time(!\"Time - task engine persistance: \"), ?task-persist-time | \"analysis-multiple-task-persist\"
			      )
		      )
	      )  
	    , analysis-default-debug-time(!\"Time - total: \") | \"analysis-multiple-total\"
      );
    	measure-time(
      	DebugResult(removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count) := <analysis-accumulate-debug-results> debug-result*;
      	<analysis-debug-results> (removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count, evaluated-task*, skipped-task*, unevaluated-task*)
      , analysis-default-debug-time(!\"Time - debug: \") | \"analysis-multiple-debug\"
      )

	analysis-accumulate-debug-results = 
		!(<id>, DebugResult(0, 0, 0, 0, 0));
		foldl(analysis-concat-debug-result)
			
	analysis-concat-debug-result:
		(
			DebugResult(removed-entry1-count, added-entry1-count, removed-task1-count, added-task1-count, invalidated-task1-count)
		, DebugResult(removed-entry2-count, added-entry2-count, removed-task2-count, added-task2-count, invalidated-task2-count)
	  )
	  ->
	  DebugResult(removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count)
	  with
	  	removed-entry-count    := <add> (removed-entry1-count, removed-entry2-count);
	  	added-entry-count      := <add> (added-entry1-count, added-entry2-count);
	  	removed-task-count     := <add> (removed-task1-count, removed-task2-count);
	  	added-task-count       := <add> (added-task1-count, added-task2-count);
	  	invalidated-task-count := <add> (invalidated-task1-count, invalidated-task2-count)

  analysis-desugar-after(desugar-after):
		Result(partition, initial-ast, analyzed-ast, changed-read*, error* , warning* , note*) ->
		(Result(partition, initial-ast, analyzed-desugared-ast, changed-read*, error* , warning* , note*), analyzed-ast)
		where
			analyzed-desugared-ast := <analysis-post-trans(|partition) <+ desugar-after> analyzed-ast
		
  analysis-update-editor(desugar-after, pp-message):
    (Result(partition, initial-ast, analyzed-desugared-ast, changed-read*, error* , warning* , note*), analyzed-ast) -> 
    Result(partition, initial-ast, analyzed-desugared-ast, changed-read*, error'*, warning'*, note'*)
    where
      not(() := initial-ast)
    with
      (error'*, warning'*, note'*) := <analysis-message-collect(pp-message|error*, warning*, note*)> analyzed-desugared-ast;
      <set-markers(|partition)> (analyzed-ast, error'*, warning'*, note'*)

  analysis-multiple-default-work-units = 
    length; !(<id>, 4); mul	
	    
rules // Message collection and updating.
	
	constraint-error = fail
	constraint-warning = fail
	constraint-note = fail
	
	enable-wrapped-message-collect = fail
	message-collect-wrapped(s)     = fail
	
  analysis-message-collect(pp-message|analysis-error*, analysis-warning*, analysis-note*):
    ast -> ([<map(pp-message)> analysis-error*, error*], [<map(pp-message)> analysis-warning*, warning*], 
    	[<map(pp-message)> analysis-note*, note*])
    with
      if enable-wrapped-message-collect then
        message-collect-wrapped(
		      error*   := <collect-all(constraint-error, conc)> ast;
		      warning* := <collect-all(constraint-warning, conc)> ast;
		      note*    := <collect-all(constraint-note, conc)> ast
		    )
		  else
		    error*   := <collect-all(constraint-error, conc)> ast;
        warning* := <collect-all(constraint-warning, conc)> ast;
        note*    := <collect-all(constraint-note, conc)> ast
      end
		    
  
  analysis-message-update-partitions-queue(|language, project-path):
  	partition* -> <queue-strategy(|\"analysis-message-update-partitions\", \"Updating messages\")> (partition*, language, project-path)
  
  analysis-message-update-partitions:
  	(partition*, language, project-path) -> <filter(not(is-test-file); analysis-message-update-partition)> partition*
  	with
    	task-setup(|project-path);
      index-setup(|language, project-path)
  	
	analysis-message-update-partition:
		partition -> <analyze-get-messages; set-only-markers(|partition)> partition
      
rules // On-save handler
	
  analysis-save-default(|language):
  	(_, _, _, _, project-path) -> None()
  	with
  		index-setup(|language, project-path);
  		index-persist;
  		task-setup(|project-path);
  		task-persist

rules // Debugging
	
	analysis-default-debug(msg) = try(analysis-default-debug-interface(msg))
	analysis-default-debug = try(analysis-default-debug-interface)
	analysis-default-debug-interface(msg) = fail
	analysis-default-debug-interface = fail
	
	analysis-default-debug-time(msg) = try(analysis-default-debug-time-interface(msg))
	analysis-default-debug-time = try(analysis-default-debug-time-interface)
	analysis-default-debug-time-interface(msg) = fail
	analysis-default-debug-time-interface = fail
	
	analysis-debug-results =
		?(
				removed-entry-count
			, added-entry-count
			, removed-task-count
			, added-task-count
			, invalidated-task-count
			, evaluated-task*
			, skipped-task*
			, unevaluated-task*
		);
  	<analysis-default-debug> $[Entries : [removed-entry-count] removed, [added-entry-count] added.];
    <analysis-default-debug> $[Tasks   : [removed-task-count] removed, [added-task-count] added, [invalidated-task-count] invalidated, [<length> evaluated-task*] evaluated, [<length> skipped-task*] skipped, [<length> unevaluated-task*] unevaluated.];
    <map(task-debug-info(|<id>); analysis-default-debug(!\"Unevaluated: \"))> unevaluated-task* 
	
"

	create-analysis-interface = 
		<output-text-file(|["lib", "runtime", "analysis"], "interface.str")>
"module runtime/analysis/interface

rules

	analysis-pre-trans = fail
	analysis-post-trans(|ctx) = fail
	analysis-disable-persist = fail
	analysis-collect = fail
	analysis-builtin-partitions = fail
	
"

	create-analysis-multiple = 
		<output-text-file(|["lib", "runtime", "analysis"], "multiple.str")>
"module runtime/analysis/multiple

imports

  runtime/analysis/core
  runtime/task/core
  runtime/nabl/utils

rules // Multi file analysis
  
  analyze-multiple(parse-file, trans, complete-work-unit, collector|language, project-path):
    path* -> (result, parse-time, trans-time, collect-time, perform-time)
    with
    	measure-time(
      	ast* := <map(analyze-parse-file(parse-file); where(complete-work-unit))> path*
    	, id, ?parse-time
    	);
    	measure-time(
      	trans* := <map(analysis-do-pre-trans(trans); where(complete-work-unit))> ast*
    	, id, ?trans-time
    	);
    	measure-time(
      	result* := <map(analyze-collect(collector|language, project-path); where(complete-work-unit))> trans*
      , id, ?collect-time
      );
      measure-time(
    		result  := <analyze-perform-all> result*
    	, id, ?perform-time
    	)

  analyze-parse-file(parse-file):
    path -> File(path, ast)
    with
      if not(ast := <file-exists; parse-file> path) then
        ast := ()
      end
      
  analysis-do-pre-trans(trans):
  	File(path, ast) -> File(path, ast, <trans> ast)

"

	create-analysis-reanalysis = 
		<output-text-file(|["lib", "runtime", "analysis"], "reanalysis.str")>
"module runtime/analysis/reanalysis

imports
	
	runtime/analysis/core
	runtime/analysis/single
	runtime/analysis/defaults
	runtime/task/core
	runtime/index/core
	runtime/nabl/collect
	runtime/nabl/namegen
	runtime/properties/collect

rules
	
	start-reanalysis(|language, path, project-path) =
		nabl-namegen-clear(|<analysis-partition(|path, project-path)>);
		index-push;
		task-push
		
	stop-reanalysis(|language, path, project-path) =
		task-pop;
		index-pop
	
	reanalysis(s|language, path, project-path) =
		where(start-reanalysis(|language, path, project-path); s; stop-reanalysis(|language, path, project-path))
	
  reanalyze-ast(|language, path, project-path):
    ast -> analyzed-ast
    with
    	property-kind* := <nabl-get-all-properties>
    ; ast' := <topdown(try(remove-property-annotations(|property-kind*)))> ast
	  ; (
	    	analyzed-ast
			, (error*, warning*, note*)
			, removed-entry*
			, added-entry*
			, removed-task*
			, added-task*
			, invalidated-task*
			, evaluated-task*
			, skipped-task*
			, unevaluated-task*
			) := <analyze-one(fail|language, path, project-path)> ast';
			
      <analysis-debug-results> (removed-entry*, added-entry*, removed-task*, added-task*, invalidated-task*, evaluated-task*, skipped-task*, unevaluated-task*);
      
      <map(analysis-default-debug(!\"Error: \"))> error*;
      <map(analysis-default-debug(!\"Warning: \"))> warning*;
      <map(analysis-default-debug(!\"Note: \"))> note*

"

	create-analysis-resolve = 
		<output-text-file(|["lib", "runtime", "analysis"], "resolve.str")>
"module runtime/analysis/resolve

imports
	
	runtime/nabl/resolve
	runtime/nabl/entries
	runtime/task/core
	runtime/index/core
	runtime/index/query
	
rules
	
	analysis-resolve(|language, project-path):
		node -> definition'
		where
			task-setup(|project-path);
    	index-setup(|language, project-path);
    	definition  := <has-annos; get-annos; fetch-elem(?Use(<id>)); task-get-results; Hd> node;
    	definition' := <index-get-all; Hd> definition // Get definition from index again to get updated origin location.
    	
	// Legacy
	analysis-resolve(|language, project-path, path) = analysis-resolve(|language, project-path)

"

	create-analysis-single = 
		<output-text-file(|["lib", "runtime", "analysis"], "single.str")>
"module runtime/analysis/single

imports
	
  runtime/analysis/core
    
rules // Single file analysis
  
  analyze-one(collector|language, path, project-path) = 
  	analyze-one(collector, id|language, path, project-path)
  
  analyze-one(collector, try-recover|language, path, project-path):
    (initial-ast, transformed-ast) -> 
    (
    	analyzed-ast
		, (error*, warning*, note*)
		, removed-entry*
		, added-entry*
		, removed-task*
		, added-task*
		, invalidated-task*
		, evaluated-task*
		, skipped-task*
		, unevaluated-task*
		)
    with
      partition := <analysis-partition(|path, project-path)>;
      r@(
      	Result(_, _, analyzed-ast, _, _, _, _)
      , DebugResult(removed-entry*, added-entry*, removed-task*, added-task*, invalidated-task*)
      ) := <analyze-collect(collector, try-recover|language, project-path)> File(partition, initial-ast, transformed-ast);
      
    	(result*, evaluated-task*, skipped-task*, unevaluated-task*) := <analyze-perform-all> [r];
    	
    	Result(_, _, _, _, error*, warning*, note*) := <Hd; Fst> result*
"

	create-analysis-singleast = 
		<output-text-file(|["lib", "runtime", "analysis"], "singleast.str")>
"module singleast

imports
	
	runtime/analysis/builtins
	runtime/analysis/core
	runtime/analysis/single
	runtime/analysis/defaults
	runtime/nabl/collect
	
rules
	
	analysis-singleast = analysis-singleast(nabl-collect)
	analysis-singleast(collector):
		ast -> (ast', messages)
		with
			language     := \"Language\";
			path         := \"path\";
			project-path := \".\";
      analysis-analyze-builtin-partitions(collector|language, project-path);
	    (ast', (e*, w*, n*), _, _, _, _, _, _, _, _) := <analyze-one(collector|language, path, project-path)> ast;
			messages := <analysis-message-collect(id|e*, w*, n*)> ast'

"

	create-editor-annotations = 
		<output-text-file(|["lib", "runtime", "editor"], "annotations.str")>
"module runtime/editor/annotations

imports
	
rules // TODO: does not belong to editor, move to a new 'utils' directory
	
	get-annotation(s) =
		has-annos;
		get-annos;
		collect-one(s)

  add-annotation(|a):
    t{a*} -> t{a, a*} where <not(is-list)> a
  
  add-annotations(|a'*):
    t{a*} -> t{a''*} where <is-list> a'*; a''* := [a'*, a*] 

  remove-annotations(s):
    t{a*} -> t{a'*}
    where
      a'* := <remove-all(s)> a*
      
  replace-annotation(s|a):
    t{a*} -> t{a, a'*}
    where
      a'* := <remove-all(s)> a*
      
  replace-annotations(s|a'*):
    t{a*} -> t{a'*, a''*}
    where
      a''* := <remove-all(s)> a*

	preserve-annotations-attachments(s) = prim(\"SSL_preserve_annotations_attachments\", s|)

"

	create-editor-dynrule = 
		<output-text-file(|["lib", "runtime", "editor"], "dynrule.str")>
"module runtime/editor/dynrule

rules
	
  editor-init =
    // Ensure all dynamic rules are properly scoped
    try(dr-scope-all-end);
    dr-scope-all-start

"

	create-editor-eclipse = 
		<output-text-file(|["lib", "runtime", "editor"], "eclipse.str")>
"module runtime/editor/eclipse

rules
	
  project-path = prim(\"SSL_EXT_projectpath\")
  
  plugin-path = prim(\"SSL_EXT_pluginpath\")
    
  refresh-workspace-file:
    path -> <prim(\"SSL_EXT_refreshresource\", path)>

"

	create-editor-editor = 
		<output-text-file(|["lib", "runtime", "editor"], "editor.str")>
"module runtime/editor/editor

imports
	
	libstratego-lib
	
	runtime/editor/-

"

	create-editor-interop = 
		<output-text-file(|["lib", "runtime", "editor"], "interop.str")>
"module runtime/editor/interop

rules
	
  foreign-call(|lang,strategy) = prim(\"SSL_EXT_foreigncall\", lang, strategy)

"

	create-editor-origins = 
		<output-text-file(|["lib", "runtime", "editor"], "origins.str")>
"module runtime/editor/origins

imports
	
	runtime/editor/eclipse

strategies
  
  origin-term      = prim(\"SSL_EXT_origin_term\", <id>)
  origin-text      = prim(\"SSL_EXT_origin_text\", <id>)
  origin-offset    = prim(\"SSL_EXT_origin_offset\", <id>)
  origin-location  = prim(\"SSL_EXT_origin_location\", <id>)
  origin-line      = origin-location => (<id>, _, _, _)
  origin-column    = origin-location => (_, <id>, _, _)
  origin-file      = prim(\"SSL_EXT_origin_file\", <id>)
  origin-strip     = prim(\"SSL_EXT_origin_strip\", <id>)
  origin-equal(|t) = prim(\"SSL_EXT_origin_equal\", <id>, t)

	origin-location-offset = prim(\"SSL_EXT_origin_location_offset\", <id>)
	origin-location-offset-set(|origin-location-offset) = prim(\"SSL_EXT_set_origin_location_offset\", origin-location-offset)

  origin-language-description =
    prim(\"SSL_EXT_languagedescription\", <id>)

  origin-language =
    origin-file; 
    origin-language-description;
    Fst
  
  origin-surrounding-comments =
    prim(\"SSL_EXT_origin_surrounding_comments\", <origin-language>, <id>)
    
  origin-documentation-comment =
    origin-surrounding-comments;
    filter(string-as-chars(documentation-comment-chars));
    concat-strings
  
  documentation-comment-chars:
    ['*' | c*] -> <ltrim(' ' + '\\t' + '\\n' + '\\r')> c*

  origin-track-forced(s) =
    ![<id>]; all(s); ?[<id>]

  origin-relative-path:
    trm -> rel-path
    where
      full-path := <origin-file> trm;
      len-project-prefix := <project-path; string-length; inc>;
      rel-path := <string-as-chars(drop(|len-project-prefix))> full-path

	origin-debug-all = topdown(try(origin-debug))
	origin-debug = where(debug(!$[[<(origin-offset; write-to-string) <+ !\"NO ORIGIN\">][\" \"]]))
	
"

	create-editor-outline-library = 
		<output-text-file(|["lib", "runtime", "editor"], "outline-library.str")>
"module runtime/editor/outline-library

imports
	
  runtime/editor/origins
  runtime/editor/annotations
  
strategies
  
  /**
   * Creates an outline given a strategy s1 that rewrites AST nodes to outline labels.
   * Only AST nodes for which s1 succeed end up in the outline.
   *
   * Example:
   *   outline = simple-label-outline(to-outline-label)
   *   to-outline-label: Entity(name, _) -> name
   *   to-outline-label: Property(name, _) -> name
   */
  simple-label-outline(s1) = collect-om(to-outline-node(s1, fail), conc)
  
  /**
   * Similar to simple-label-outline(s1), but with an additional strategy s2 that rewrites
   * AST nodes to outline nodes. Strategy s2 gets priority over strategy s1 in case both succeed.
   *
   * Example:
   *   outline = custom-label-outline(to-outline-label, to-outline-node)
   *   to-outline-label: Entity(name, _) -> name
   *   to-outline-node: Property(name, _) -> Node(name, [Node(\"dummy\", [])])
   */
  custom-label-outline(s1, s2) = collect-om(origin-track-forced(s2) <+ to-outline-node(s1, s2), conc)

  /**
  * @internal
  * Note: we annotate labels with random numbers to guarantee that similar labels do not share the
  * same in-memory term, which would cause origins to be overwritten.
  */  
  to-outline-node(s1, s2):
    term -> Node(label, children)
    where
      random := <next-random>;
      label := <origin-track-forced(s1; term-to-outline-label; add-annotation(|random); remove-annotations(?random))> term;
      children := <get-arguments; custom-label-outline(s1, s2)> term
      
  /**
  * @internal
  */  
  term-to-outline-label =
    is-string 
      <+
    ?term{a}; origin-text; ?label; !label{a}
      <+
    write-to-string // fallback

rules

rules
  
  /**
  * Given a string of literals (e.g. \"context-free syntax\"), converts the string
  * into an outline label by providing it with origin information. The result is
  * that the correct portion of text in the editor gets selected, upon selecting
  * nodes with this label in the outline view.
  * Note: this strategy is useful for constructing outline labels for unnamed
  * elements. 
  *
  * @param term (e.g. 'context-free-syntax([])') provides the origin.
  */  
  literals-to-outline-label(|term):
    literals -> literals
    where
      literals' := <split-at-space> literals;
      (a, b, c, d, e) := <origin-location-offset> term;
      (before, after) := <split-before> (<origin-text> term, <Hd> literals');
      start-offset := <add> (d, <string-length> before);
      end-offset := <get-literals-end-offset(|literals', start-offset)> after;
      <origin-location-offset-set(|(a, b, c, start-offset, end-offset))> literals
      
  /**
  * @internal
  */      
  get-literals-end-offset(|literals, start-offset):
    text -> end-offset
    where
      (before, after) := <split-after> (text, <Hd> literals);
      end-offset := <get-literals-end-offset(|<Tl> literals, <add> (start-offset, <string-length> before))> after

  /**
  * @internal
  */
  get-literals-end-offset(|literals, start-offset):
    _ -> <dec> start-offset
    where
      [] := literals

rules

  /**
  * Given a term application, gets the portion of the origin text up to the start
  * of the origin text of the first subterm. If the result is an empty string, it
  * gets the origin text of the first subterm instead. Excess whitespace, such as
  * tabs and new lines, are removed.
  */
  origin-text-at-start:
    term -> result'
    where
      (cons, args) := <explode-term> term;
      offset1 := <origin-offset; ?(<id>, _)> term;
      offset2 := <Hd; origin-offset; ?(<id>, _)> args;
      offset-diff := <subt> (offset2, offset1);
      if (0 := offset-diff)
      then result' := <Hd; origin-text; guarantee-one-space-separation> args
      else result := <origin-text; explode-string; take(!offset-diff); rtrim(is-whitespace + test('\\n')); implode-string> term;
        result' := <guarantee-one-space-separation> result;
        (a, b, c, d, e) := <origin-location-offset> term;
        <origin-location-offset-set(|(a, b, c, d, <add> (d, <string-length; dec> result)))> result'
      end
  
  /**
  * @internal
  */
  guarantee-one-space-separation = string-as-chars(
      map(try(test('\\n' + ' '); !' '));
      foldr(![], rm-double-space <+ MkCons)
    )
  rm-double-space: (' ', l@[' '|xs]) -> l
  
signature constructors
  
  Node: label * children -> Node

"

	create-editor-positions = 
		<output-text-file(|["lib", "runtime", "editor"], "positions.str")>
"module runtime/editor/positions

signature constructors

  MARKER: Term
  
strategies

  desugar-position(desugar|ast):
    position -> position'
    where
      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
   
  at-position(s|position):
    c#(t*) -> t'
    where
      !position => [i | position']
    where
      t' := c#(<at-index(at-position(s|position'))> (i, t*))

  at-position(s|position):
    t -> t'
    where
      !position => [];
      t' := <s> t

  position-of-term(is-term):
    t -> []
    where
      is-term
  
  position-of-term(is-term):
    _#(t*) -> <position-of-term(is-term|0)> t*
    where
      not(is-term)
  
  position-of-term(is-term|start-index):
    [t | t*] -> position
    where
      if i* := <position-of-term(is-term)> t then
        position := [start-index | i*]
      else
        position := <position-of-term(is-term | <inc> start-index)> t*
      end

  term-at-position(|position):
    t -> t'
    where
      at-position(?t'|position) 

  parent-at-position(|position):
    t -> t'
    where
      !position => [i, _];
      t' := <subterm-at(|i)> t
  
  parent-at-position(|position):
    t -> <parent-at-position(|position')> t'
    where
      !position => [i | position' @ [_, _ | _]];
      t' := <subterm-at(|i)> t

  subterm-at(|index):
    _#(t*) -> <index(|<inc> index)> t*

"

	create-editor-properties = 
		<output-text-file(|["lib", "runtime", "editor"], "properties.str")>
"module runtime/editor/properties

imports

	libstratego-gpp	
	runtime/editor/interop
	
	runtime/index/core
	runtime/nabl/collect
	runtime/nabl/entries
	runtime/nabl/uri
	runtime/properties/collect
	runtime/properties/query
	runtime/task/core
	runtime/types/query
	runtime/types/collect
  
rules	// Properties
	
	get-editor-properties(language-pp | language, project-path) = 
		get-all-editor-properties(language-pp | language, project-path)
	; filter(not-none)
	
	get-all-editor-properties(language-pp | language, project-path):
		t ->
			<concat
			;map(\\(a,b)->(a,<pp-property>b)\\)>
			[
				[
					(\"Target\",			<target-prop(language-pp)>t),
					(\"Target Constructor\",<cons-prop>t),
				 	(\"Name\",				<name-prop>t),
				 	(\"Defines\",			<def-prop>t),
				 	(\"Refers to\",		<ref-prop>t)
				]
			,	<nabl-props>t
			]
			with
	    	index-setup(|language, project-path);
	    	task-setup(|project-path)
	
	target-prop(language-pp): t -> tar
		with
			tar := <pp-ast(language-pp)>t <+
			tar := None()
	
	cons-prop: _ -> None()
		where is-string
	cons-prop: t -> constr
		where not(is-string)
		with
			constr := <pp-cons>t <+
			constr := None()
	
	type-prop: t -> type
		with
			type := <get-type>t <+
			type := None()

	name-prop: t -> name
		where
			name := <nabl-get-name>t <+
			name := None()

	def-prop: t -> uri
		with
			uri := <nabl-collect-def;nabl-uri;pp-uri>t <+
			uri := None()

	ref-prop: Def(uri) -> <pp-uri>uri	//TODO: remove this when we can use hover without resolving	
	ref-prop: t -> uri
		with
			uri := <nabl-collect-use;nabl-uri;pp-uri>t <+
			uri := None()
	
	nabl-props: t -> props
		with
			nabl-props := [Type()|<nabl-collect-custom-properties>]
		with
			props := <map(nabl-prop(|t))> nabl-props <+
			props := []
	nabl-prop(|t): p -> <nabl-prop>(t, p)
	nabl-prop: (t, property) -> (name, prop)
		with
			name := <pp-nabl-prop-name>property
		with
			prop := <get-properties(|property);de-list;not(?Result(_); task-has-failed)>t <+
			prop := <get-property(|property)	;				 not(?Result(_); task-has-failed)>t <+
			prop := None()
		
rules // helper rules: filtering

	not-none: (a, b) -> (a, b)
		where
			<not(eq)>(b, None())
		; <not(eq)>(b, \"-\")
	
	de-list: [] -> None()
	de-list: [a] -> a
	de-list: [a|rest] -> [a|rest]
	
rules // helper rules: formatting
	
	pp-ast(language-pp) = topdown(try(rm-annotations));language-pp
	
	pp-cons: t -> $[[<get-constructor> t]/[<get-arguments;length> t]]
	
	pp-uri = reverse-uri;foreign-call(|\"Analysis\", \"make-abstract\");foreign-call(|\"Analysis\", \"prettyprint-example\");box2text-string(|80)
	
	reverse-uri: URI(language, uri) -> URI(language, <reverse>uri)
	
	pp-nabl-prop-name : Type() -> \"Type\"
	pp-nabl-prop-name = write-to-string;string-replace(|\"NablProp_\",\"\");string-replace(|\"-\",\" \");upper-case-first
	
	upper-case-first: string -> <implode-string>[<to-upper>c|hars]
		with [c|hars] := <explode-string>string
	
	pp-property: a -> a
		where is-string
	pp-property: None() -> \"-\"
	pp-property: a -> <map(pp-property;\\x->(\"\",x)\\)>a
		where is-list
	pp-property: Def(uri) -> <pp-uri>uri
	pp-property = topdown(try(rm-annotations));write-to-string
	
rules // helper rules: format to HTML for hover
	
	properties-to-html = map(property-to-html);separate-by(|\"<br/>\\n\");concat-strings
	property-to-html: (\"\", prop) -> $[[<property-to-html>prop]]
	property-to-html: (name, prop) -> $[<b>[name]</b>: [<property-to-html>prop]]
	property-to-html: list -> $[<div>[<properties-to-html>list]</div>]
		where is-list
	property-to-html: prop -> prop

"

	create-editor-queue = 
		<output-text-file(|["lib", "runtime", "editor"], "queue.str")>
"module runtime/editor/queue

rules
	
  // Set markers and analyzed AST for a given file. Use when checking files from a queued strategy.
  // Current term: (ast-analyzed, errors, warnings, notes) tuple
  // fileOrAST: file to set the markers on or the root node of the file to set markers on 
  set-markers(|fileOrAST) = prim(\"SSL_EXT_set_markers\", fileOrAST)
  
  // Set only the markers for given file, does not change the stored AST.
  // Current term: (errors, warnings, notes) tuple
  // fileOrAST: file to set the markers on or the root node of the file to set markers on 
  set-only-markers(|fileOrAST) = prim(\"SSL_EXT_set_only_markers\", fileOrAST)

  // Indicate that one or more files need analysis. 
  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
  queue-analysis = 
       (is-list; list-loop(queue-analysis))
    <+ prim(\"SSL_EXT_queue_analysis\")
    
  // Gets the number of background analyses for currenct project and language.
  // Current term: ignored
  analysis-count = prim(\"SSL_EXT_queue_analysis_count\")

  // Set the total number of work units to complete. Can be called multiple times. 
  // Current term: number of work units (int).
  set-total-work-units = prim(\"SSL_EXT_set_total_work_units\")
  
  // Complete one work unit and update progress monitors.
  // Current term: ignored
  complete-work-unit = prim(\"SSL_EXT_complete_work_unit\")
  
  // Queue a strategy for background processing with a progress indicator.
  // Current term: the term to pass to the background strategy
  // s: the strategy, as string
  // description: name of the task (will be shown in progress view)
  queue-strategy(|s,description) = prim(\"SSL_EXT_queue_strategy\", s, description)
  
  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
  set-analysis-backgrounded = !\"BACKGROUNDED\"

"

	create-index-core = 
		<output-text-file(|["lib", "runtime", "index"], "core.str")>
"module runtime/index/core

imports
	
	runtime/index/utils

signature

  sorts
  
    URI Entry
  
rules

  /**
   * Sets up the index library for given language, project paths and current file.
   * Must be called once before doing anything with the library.
   *
   * Example:
   *   <index-setup(|\"MiniJava\", <project-path>)
   *
   * @param language          The language to set the index up for.
   * @param project-path      The project path that contains all source files to analyse.
   * @type x -> x
   */
  index-setup(|language, project-path) =
    prim(\"LANG_index_setup_new\", language, <index-setup-paths> project-path)
    
  index-setup:
  	(language, project-path) -> <prim(\"LANG_index_setup_new\", language, <index-setup-paths> project-path)>
    
  /**
   * Unloads the currently loaded index.
   *
   * Example:
   *   index-unload(|<project-path>)
   *
   * @param project-path The project path that contain all source files to analyse and compile.
   *
   * @type x -> x
   */
  index-unload(|project-path) =
    prim(\"LANG_index_unload\", project-path)

  /**
   * Tries to recover the index from an invalid state, for example after a crash.
   */
	index-recover =
		prim(\"LANG_index_recover\")
		
	/**
	 * Starts collection for given partition. Used in conjunction with index-stop-collection to 
	 * retrieve a list of added and removed index entries in relation to the previous entries in
	 * given partition.
	 *
	 * Example:
	 *   index-start-collection(|\"fullpath/file.ext\")
	 *   index-start-collection(|(\"fullpath/file.ext\", \"subfile\"))
	 *
	 * @type x -> x
	 */
	index-start-collection(|partition) =
		prim(\"LANG_index_start_collection\", partition)
		
	/**
	 * Stops collection for the partition on which index-start-collection was called. Returns 
	 * a tuple with removed and added entries in relation to the previous entries in that partition.
	 *
	 * Example:
	 *   index-stop-collection => (removed, added)
	 *
	 * @type x -> (List(elem), List(elem))
	 */
	index-stop-collection =
		prim(\"LANG_index_stop_collection\")
	
	/**
	 * Pushes a new index on the stack and sets that as the current index. Entries from the parent
	 * index are still visible, but additions only apply to the current index. Clearing a partition
	 * also hides all entries in that partition from the parent index.
	 *
	 * Example:
	 *   index-push
	 *
	 * @type x -> x 
	 */	
	index-push = 
		prim(\"LANG_index_push\")

	/**
	 * Pops the current index from the stack and sets the parent index as the current index. All
	 * modifications from the current index are discarded. The root index cannot be popped.
	 *
	 * Example:
	 *   index-pop
	 *
	 * @type x -> x 
	 */	
	index-pop = 
		prim(\"LANG_index_pop\")

	/**
	 * Pops the current index from the stack and sets the parent index as the current index. All
	 * modifications from the current index are merged into the parent index; partitions that were
	 * cleared in the current index are cleared in the parent, and entries added to the current
	 * index are also added to the parrent. The root index cannot be merged.
	 *
	 * Example:
	 *   index-merge
	 *
	 * @type x -> x 
	 */	
	index-merge = 
		prim(\"LANG_index_merge\")
		
  /**
   * Adds given element to the index.
   *
   * Example:
   *   <index-add(|\"fullpath/file.ext\")> Def([Entity(), \"Bar\"])
   *   <index-add(|(\"fullpath/file.ext\", \"subfile\"))> Def([Entity(), \"Bar\"])
   *
   * @param partition The partition to add the element to.
   * @type x -> ?x
   */
  index-add(|partition) =
    prim(\"LANG_index_add\", <id>, partition)

  /**
   * Adds all given elements to the index.
   *
   * Example:
   *   <index-add-all(|\"fullpath/file.ext\")> [Def([Entity(), \"Bar\"]), ...]
   *   <index-add-all(|(\"fullpath/file.ext\", \"subfile\"))> [Def([Entity(), \"Bar\"]), ...]
   *
   * @param partition The partition to add the elements to.
   * @type List(x) -> ?List(x)
   */
  index-add-all(|partition) =
    list-loop(with(index-add(|partition)))
    
  /**
   * Removes all elements from the index that are contained in given partition.
   *
   * Example:
   *   <index-clear-partition> \"fullpath/file.ext\"
   *   <index-clear-partition> (\"fullpath/file.ext\", \"subfile\")
   *
   * @type x -> ?x
   */
  index-clear-partition = 
    prim(\"LANG_index_clear_partition\", <id>)
    
  /**
   * Removes all elements from the index.
   *
   * @type x -> x
   */
  index-reset = 
    prim(\"LANG_index_clear_all\")
    
  /**
   * Removes all elements from the index and re-analyzes all partitions in the project.
   *
   * @type x -> x
   */
  index-reload = 
    prim(\"LANG_index_reload\")
   
  /**
   * Persists index to a cache on disk.
   *
   * @type x -> x
   */
  index-persist = 
    prim(\"LANG_index_persist\")

"

	create-index-globals = 
		<output-text-file(|["lib", "runtime", "index"], "globals.str")>
"module runtime/index/globals

imports

	runtime/index/core
	runtime/index/query
  
signature 

  constructors
    
    Global : URI               -> Entry
    Global : URI * List(Entry) -> Entry
    
rules
    
  /**
   * Gets the 'fake' path where globals are stored in the index.
   *
   * @internal
   */
  index-globals-path:
  	names -> <separate-by(|\"/\"); concat-strings> path
    with
      if is-list then
        path := <concat> [names, [\"globals\", \".internal\"]]
      else
        path := [names, \"global\", \".internal\"]
      end
    
  /**
   * Gets the URI where globals are stored in the index for given name or names.
   *
   * @internal
   * @type name or List(name) -> uri
   */
  index-globals-uri:
    names -> uri
    with
      if is-list then
        uri := <concat> [names, [\"globals\", \".internal\"]]
      else
        uri := [names, \"global\", \".internal\"]
      end
    
  /**
   * Gets the first value in global storage with given name, or fail.
   *
   * Example:
   *   index-get-global(|\"last-compile\") => Timestamp(1334322856)
   *   index-get-global(|[\"last-compile\", \"file.str\"]) => Timestamp(1334322856)
   * 
   * @param name  The name or list of names to identify the global value.
   * @type _ -> ?value
   */
  index-get-global(|name):
    _ -> value
    where
      Global(_, value) := <index-get-all; Hd> Global(<index-globals-uri> name, ())
    
  /**
   * Gets all values in global storage with given name.
   *
   * Example:
   *   index-get-global(|\"last-compile\") => [Timestamp(1334322856), ...]
   *   index-get-global(|[\"last-compile\", \"file.str\"]) => [Timestamp(1334322856), ...]
   *
   * @param name  The name or list of names to identify the global value.
   * @type _ -> List(value)
   */ 
  index-get-all-globals(|name):
    _ -> values'
    with
      values  := <index-get-all> Global(<index-globals-uri> name, ());
      values' := <filter(?Global(_, <id>))> values
    
  /**
   * Add value to global storage with given name.
   *
   * Example:
   *   <index-add-global(|\"last-compile\")> Timestamp(1334322856)
   *   <index-add-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-add-global(|name):
    value -> <id>
    with
      <index-add(|<index-globals-path>)> Global(<index-globals-uri> name, value)
      
  /**
   * Overwrites value in global storage with given value.
   *
   * Example:
   *   <index-set-global(|\"last-compile\")> Timestamp(1334322856)
   *   <index-set-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-set-global(|name):
    value -> <id>
    with
      index-clear-global(|name);
      <index-add-global(|name)> value
    
  /**
   * Removes all values from global storage with given name.
   *
   * Example:
   *   index-clear-global(|\"last-compile\")
   *   index-clear-global(|[\"last-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-clear-global(|name):
    _ -> <id>
    with
      <index-globals-path; index-clear-partition> name
rules
	
  /**
   * Gets the 'fake' path where boolean globals are stored in the index.
   *
   * @internal
   */
  index-boolean-globals-path:
  	names -> <separate-by(|\"/\"); concat-strings> path
    with
      if is-list then
        path := <concat> [names, [\"boolean\", \"globals\", \".internal\"]]
      else
        path := [names, \"boolean\", \"global\", \".internal\"]
      end
	      
  /**
   * Gets the URI where boolean globals are stored in the index for given name or names.
   *
   * @internal
   */
  index-boolean-globals-uri:
    names -> uri
    with
      if is-list then
        uri := <concat> [names, [\"boolean\", \"globals\", \".internal\"]]
      else
        uri := [names, \"boolean\", \"global\", \".internal\"]
      end
      
  /**
   * Sets boolean value true to global boolean storage with given name.
   *
   * Example:
   *   index-enable-global(|\"can-compile\")
   *   index-enable-global(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> x
   */   
  index-enable-global(|name):
    _ -> <id>
    with
      <index-add(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
      
  /**
   * Sets boolean value false to global boolean storage with given name.
   *
   * Example:
   *   index-disable-global(|\"can-compile\")
   *   index-disable-global(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> x
   */   
  index-disable-global(|name):
    _ -> <id>
    with
      <index-boolean-globals-path; index-clear-partition> name
      
  /**
   * Query for boolean value true in global boolean storage with given name.
   *
   * Example:
   *   index-is-global-enabled(|\"can-compile\")
   *   index-is-global-enabled(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> ?x
   */   
  index-is-global-enabled(|name):
    _ -> <id>
    where
      <index-get-all; Hd> Global(<index-boolean-globals-uri> name)

"

	create-index-legacy = 
		<output-text-file(|["lib", "runtime", "index"], "legacy.str")>
"module runtime/index/legacy

imports
	
	runtime/index/core
	runtime/index/utils

rules // Redirects
	
	index-setup(|language, project-path, current-partition) =
		index-setup(|language, <index-setup-paths> project-path)
		
	index-clear = index-reset
	index-clear-all = index-reset
	
	index-commit = index-persist
		
rules // Deprecated
		
	index-depricated-switch = fail
	index-depricated = try(not(index-depricated-switch); with(fail|\"Deprecated.\"))
		
	index-get-all-with-partitions = index-depricated
		
  index-remove(|partition) = index-depricated
    
  index-remove-all = index-depricated
    
  index-remove-one = index-depricated
  
  index-get-current-partition = index-depricated
  
  index-set-current-partition = index-depricated
  
  index-get-partition-revision = index-depricated
    
  index-start-transaction = index-depricated
  
  index-end-transaction = index-depricated
  
  index-transaction(s) = index-depricated; s

"

	create-index-partition = 
		<output-text-file(|["lib", "runtime", "index"], "partition.str")>
"module runtime/index/partition

rules // Construction
  
  index-create-partition(|file) =
    !file
    
  index-create-partition(|file, uri) =
    !(file, uri)

rules // Projections
	
	index-partition-file:
		(file, _) -> file
		
	index-partition-file:
		file -> file
		where
			<is-string> file
		
  index-partition-uri:
  	(_, uri) -> uri
"

	create-index-query = 
		<output-text-file(|["lib", "runtime", "index"], "query.str")>
"module runtime/index/query

rules

  /**
   * Get all index entries that match the given template.
   *
   * Example:
   *   <index-get-all> Def([Entity(), \"Bar\"]) => [Def([Entity(), \"Bar\"]), ...]
   *
   * @type template -> List(elem)
   */
  index-get-all:
    template -> <prim(\"LANG_index_get\", template)>

  /**
   * Get all children entries of the given template.
   *
   * Example:
   *   <index-get-children> Def([Entity(), \"Bar\", \"Foo\"]) => [Def([Method(), \"Bar\"]), Def([Field(), \"Baz\"]), ...]
   *
   * @type template -> List(elem)
   */    
  index-get-children:
    template -> <prim(\"LANG_index_get_children\", template)>
  
  /**
   * Gets a list of all partitions for current project.
   *
   * Example:
   *   <index-get-all-partitions> => [(\"fullpath/file.ext\", \"subfile\"), ...]
   *
   * @type x -> List(partition)
   */   
  index-get-all-partitions =
    prim(\"LANG_index_all_partitions\")
  
  /**
   * Gets all index entries for the given partition.
   *
   * Examples:
   *   <index-get-all-in-partition> \"fullpath/file.ext\" => [Def([Entity(), \"Bar\"]), ...]
   *   <index-get-all-in-partition> (\"fullpath/file.ext\", \"subfile\") => [Def([Entity(), \"Bar\"]), ...]
   *
   * @type partition -> List(elem)
   */  
  index-get-all-in-partition =
    prim(\"LANG_index_get_all_in_partition\", <id>)

  /**
   * Gets the containing partitions of index entry with given template.
   *
   * Example:
   *   <index-get-partitions-of> Def([Entity(), \"Bar\"]) => [(\"fullpath/file.ext\", \"subfile\"), ...]
   *
   * @type template -> List(partition)
   */  
  index-get-partitions-of:
    template -> <prim(\"LANG_index_get_partitions_of\", template)>

"

	create-index-utils = 
		<output-text-file(|["lib", "runtime", "index"], "utils.str")>
"module runtime/index/utils

rules
	
	index-setup-paths = try(is-list; Hd)
"

	create-modelware-model2tree = 
		<output-text-file(|["lib", "runtime", "modelware"], "model2tree.str")>
"module runtime/modelware/model2tree

imports
  
  runtime/modelware/signatures
  runtime/nabl/-
  runtime/editor/origins

rules
  
  mw-model2tree: M(obj)                    -> <origin-track-forced(mw-obj2term)> obj
  mw-obj2term  : Obj(_, QID(\"ast\", c), s*) -> c#(<map(mw-slot2term)> s*)
  mw-slot2term : None()                    -> None()
  mw-slot2term : Some(val)                 -> Some(<mw-val2term> val)
  mw-slot2term : []                        -> []
  mw-slot2term : val                       -> <mw-val2term>
  mw-val2term  : Data(val)                 -> val
  mw-val2term  : Link(uri)                 -> <mw-name-of + map(mw-name-of)> uri
  mw-val2term  : Contain(obj)              -> <mw-obj2term + map(mw-obj2term)> obj
  
rules
  
  mw-name-of = ?URI(_, <id>); Hd; ?ID(_, <id>, _)

"

	create-modelware-modelware = 
		<output-text-file(|["lib", "runtime", "modelware"], "modelware.str")>
"module runtime/modelware/modelware

imports
	
	libstratego-lib
	
	runtime/modelware/-

"

	create-modelware-signatures = 
		<output-text-file(|["lib", "runtime", "modelware"], "signatures.str")>
"module runtime/modelware/signatures

signature constructors // grammar

  // TODO

signature constructors // metamodel
  
  // TODO
  
signature constructors // model
  
  M         : Object                      -> Model
  Obj       : Opt(URI) * QID * List(Slot) -> Object
            : Value                       -> Slot
            : Opt(Value)                  -> Slot
            : List(Value)                 -> Slot
  Data      : String                      -> Value
  Contain   : Object                      -> Value
  Link      : QID                         -> Value
  QID       : PackName * ClassName        -> QID
  Unresolved:                                QID

"

	create-modelware-tree2model = 
		<output-text-file(|["lib", "runtime", "modelware"], "tree2model.str")>
"module runtime/modelware/tree2model

imports
  
  runtime/modelware/signatures
  runtime/nabl/-
  runtime/index/-
  runtime/editor/-

rules
  
  mw-tree2model: t       -> M(<origin-track-forced(mw-term2obj)>)
  mw-term2obj  : c#(t*)  -> Obj(<mw-def-uris>, QID(\"ast\", c), <map(mw-term2slot)> t*)
  mw-term2slot : None()  -> None()
  mw-term2slot : Some(t) -> Some(<mw-term2val> t)
  mw-term2slot : t*      -> <map(mw-term2val); mw-combine>
  mw-term2slot : t       -> <mw-term2val>
  mw-term2val  : t       -> Data(t) where is-string; not(mw-ref-uri)
  mw-term2val  : t       -> Link(<mw-ref-uri>)
  mw-term2val  : t       -> Contain(<origin-track-forced(mw-term2obj)> t) where mw-is-compound

rules
  
  mw-def-uris    = get-arguments; map(get-annos; filter(?Def(_); try(origin-location))); concat
  mw-ref-uri     = get-annos; fetch-elem(?Use(_)); (nabl-collect-one-resolved-def; index-get-all; Hd; ?Def(_); try(origin-location) <+ ?Use(<id>) <+ !Unresolved())
  mw-is-compound = where(not(?Some(_))); explode-term + map(explode-term)
  
  mw-combine = ?[]
  mw-combine:
    t* -> c#([<map(get-arguments; Hd)> t*])
    where
      c#(_) := <Hd> t*

"

	create-nabl-check = 
		<output-text-file(|["lib", "runtime", "nabl"], "check.str")>
"module runtime/nabl/check

imports
	
	runtime/nabl/resolve
	runtime/nabl/collect
	runtime/nabl/query
	runtime/nabl/tasks
	runtime/nabl/entries
	runtime/nabl/interface
	runtime/nabl/uri
	runtime/nabl/utils
	runtime/task/core
	runtime/task/messages
	runtime/task/tasks
	
rules // Error checking tasks
	
	nabl-unresolved-task(|partition, task):
		name -> name
		where
			not(nabl-check-disable-unresolved)
		with
			<nabl-fix-name; task-create-error-on-failure(|partition, task, \"Unresolved reference\")> name
			
	nabl-duplicate-task(|ctx, unique):
		name -> name
		where
			uri := <nabl-uri> name;
			ns	:= <nabl-uri-namespace> uri;
			not(<nabl-check-disable-duplicate(|uri, ns)> name)
		with
			if Unique() := unique then
				uri'		:= <nabl-uri-parent> uri;
				resolve := <nabl-create-resolvedefs(|ctx, ns, name, [])> uri';
				<task-create-error-on-multiple(|ctx, resolve, \"Duplicate definition\")> name
			end

rules // Legacy
 
	nabl-is-unresolved =
		?node;
		has-annos;
		get-annos;
		where(nabl-has-reference);
		not(nabl-collect-one-resolved-def)
	
	nabl-get-ambiguities =
		nabl-collect-all-resolved-defs;
		mapconcat(nabl-get-all-aliases);
		filter(nabl-uri; nabl-uri-parent);
		make-set;
		where(<gt> (<length>, 1))
	
	nabl-get-duplicate-definitions =
		has-annos;
		get-annos;
		collect-one(?Def(_));
		nabl-get-all-definitions;
		make-set;
		where(<gt> (<length>, 1))

"

	create-nabl-collect = 
		<output-text-file(|["lib", "runtime", "nabl"], "collect.str")>
"module runtime/nabl/collect

imports
	
	runtime/task/core
	runtime/task/tasks
	runtime/task/messages
	runtime/nabl/tasks
  runtime/nabl/entries
  runtime/nabl/check
  runtime/nabl/namegen
  runtime/nabl/interface
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/properties/collect
  runtime/properties/entries
  runtime/properties/tasks
	runtime/editor/origins
	runtime/editor/annotations
	runtime/types/collect

signature 

	sorts
	
		State DefScope ImplicitDef Use RefScope Range

  constructors // state
  	
  	State : String * Term -> State

	constructors // def

		Current    :                  	DefScope
		Subsequent :                   	DefScope
		DefScope   : Term            -> DefScope
    Scope      : Namespace       -> Scope
    FixedScope : Namespace * URI -> Scope
    
  constructors // use
      
		UseCandidate  : Namespace * List(Property) * RefScope * WildcardImport * List(Dependency) -> Use
		
		True  : WildcardImport
		False : WildcardImport
	
		Current     :                                     							RefScope
		Surrounding :                                  	 							  RefScope
		Context     : String * Namespace * List(Property) * RefScope -> RefScope
		RefScope    : Term                                           -> RefScope
    
    Completion : Result -> Completion
	
	constructors // import
	  
	  Wildcard : List(Import) * RefScope * DefScope * List(Dependency) -> ImportDesc
	  Single   : Namespace * Term * DefScope * List(Dependency) -> ImportDesc
	  Imported : Namespace                   -> Namespace
	  Import   : Namespace                   -> Property
	  Import   : Language * Namespace        -> Property
	  Import   : Language * Namespace * Name -> Property
  	  
  constructors // partition
  
  	CollectPartition : Partition
	
	constructors // annotation
	  
	  ExternalDef  : URI -> Anno
    
strategies // generic traversal
	
	/**
	 * Performs the collection in a topdown traversal. 
	 * At each node, it tries various calls to generated strategies, which call back to generic strategies.
	 */
	nabl-collect(sibling-uris|lang, partition, unique*, uri*) =
	  nabl-state-pop(?state*)
  ; try(nabl-scoping-site)
  ; (
		   nabl-scope-site(?uri'*|lang, partition, unique*, uri*)
		<+ nabl-new-scope-site(?uri'*|lang, partition, unique*, uri*)
		<+ match(?uri'*|uri*) 
		) 
  ; (
			 nabl-def-site(?child-uri*, sibling-uris, ?implicit*|lang, partition, unique*, uri'*, state*)
     ; try(nabl-new-scoping-site)
    <+ match(sibling-uris|uri*)
     ; match(?child-uri*|uri'*)
    )    
  ; try(nabl-state-site)
  // visit children from left to right
  ; try(nabl-collect-rewrite(|lang, partition, uri*, uri'*))
  ; preserve-annos(origin-track-forced(id#(nabl-siblings(|lang, partition, unique*, child-uri*))))
  ; try(nabl-external-def-site(|lang, partition, unique*, uri'*, state*, implicit*))
  ; try(nabl-use-site(|lang, partition, unique*, uri'*, state*))
  ; try(nabl-import-site(|lang, partition, unique*, child-uri*, state*))
  ; try(nabl-filtering-site(|lang, partition, unique*, uri*, state*))
  ; try(nabl-disambiguation-site(|lang, partition, unique*, uri*, state*))
  ; try(nabl-prop-site(|lang, partition, uri*, state*, implicit*))
  ; nabl-annotate-properties(|lang, partition, uri*, uri'*)
    
	nabl-siblings(|lang, partition, unique*, uri*) = 
		[]  
	+ [ nabl-collect(?sibling-uri*|lang, partition, unique*, uri*)
		| nabl-siblings(|lang, partition, unique*, sibling-uri*) ]

rules // generic analysis of state
  
  nabl-state(pattern|state) =
    map(try(nabl-state-annotate(pattern|state)))
      
  nabl-state-annotate(pattern|state) =
    ?pattern; add-annotation(|state)
    
  nabl-state-pop(states'):
  	term{anno*} -> term'
  	where
  		state* := <collect-all(?State(_, _))> anno*;
  		term'  := <remove-annotations(?State(_, _))> term;
  		match(states'|state*)
  		
  nabl-get-state(|name) =
  	fetch-elem(?State(name, _))

rules // generic analysis of scopes
	
	nabl-scope-site(adapted-uris|lang, partition, unique*, uri*) =
	  remove-annotations(?Scope(ns*))
	; where (
	  	uri'* := <extend-scope-uri(nabl-extend-uri-anonymous(|unique*, partition)|lang)> (ns*, uri*)
	  ; match(adapted-uris| uri'*)
	  ; scope-uri* := <map(!(<id>, <lookup-uri(|uri'*)>))> ns*
	  )
	; add-annotation(|Scope(scope-uri*))
	
	nabl-new-scope-site(adapted-uris|lang, partition, unique*, uri*) =
    remove-annotations(?FixedScope(ns, uri))
  ; where (
      uri'* := <update-scope-uri(!uri|lang)> (ns, uri*)
    ; match(adapted-uris| uri'*)
    )
  ; add-annotation(|Scope([(ns, uri)]))
     
	nabl-scope(|ns1*) = 
	   remove-annotations(?Scope(ns2*))
	 ; add-annotation(|Scope(<union> (ns1*, ns2*)))
	<+ add-annotation(|Scope(ns1*))
	 
rules // generic analysis of defs
    	
	// call back to generic analysis
	nabl-def(child-uris, sibling-uris|lang, partition, unique*, child-uri*, sibl-uri*, ns, unique, defscope, scoped, nt-scoped):
		a@name{anno*} -> name''
		where
			// get URI for namespace of definition site
			current-uri := <lookup-uri(|lang, ns)> child-uri*
		with
			// generate a name if needed
			name' := <try(nabl-namegen(|lang, partition, unique*, child-uri*, anno*))> name
		where
			switch !defscope
			  // in each case we 
			  // 1. build URI of the definition site
			  // 2. update URIs for children (vertical scope)
			  // 3. update URIs for right siblings (horizontal scope)
			 
			  // 1st case: definition in current scope
			  case Current(): 
		
			  // 1. extend current URI with ID segment
			  // 2. extend URIs of scoped name'spaces
		 	  // 3. preserve
			    def-uri         := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> current-uri
			  ; nt-def-uri      := <nabl-uri-add-barriers(|nt-scoped)> def-uri
			  ; new-child-uri*  := <replace-scope-uri(|def-uri)> (scoped, child-uri*)
				; new-child-uri'* := <replace-scope-uri(|nt-def-uri)> (nt-scoped, new-child-uri*)
			  ; match(child-uris|new-child-uri'*)
			  ; match(sibling-uris|sibl-uri*)
		   
		    // 2nd case: definition in subsequent scope and maybe in external scopes
		    case fetch-elem(?Subsequent()) => def-scope*:
		       
			  // 1. extend current URI with subsequent and ID segment
			  // 2. preserve
			  // 3. extend URI for name'space of definition site with Subsequent segment
			    subs-uri := <nabl-extend-uri-subsequent(|unique*, partition)> current-uri
			  ; def-uri  := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> subs-uri
		    ; match(child-uris|child-uri*)
			  ; match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], sibl-uri*))
		
		    // 3rd case: definition only in external scopes
		    case is-list => def-scope*:
			  
		    // 1. extend base URI with anonymous and ID segment
		    // 2. preserve
		    // 3. preserve
		      ano-uri := <nabl-base-uri; nabl-extend-uri-anonymous(|unique*, partition)> lang 
		    ; def-uri := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> ano-uri
			  ; match(child-uris|child-uri*)
			  ; match(sibling-uris|sibl-uri*)
		  end
    with
			// Add Def entry to the index. Strip barriers from URI so that barriers don't end up in the index.
			d      := <new-def(|partition, <nabl-uri-strip-barriers> def-uri)> a;
			name'' := <replace-annotation(?Def(_)|d)> name'
		with
			<try(nabl-duplicate-task(|partition, unique))> name''
	
	nabl-def-alias(|partition, def-uri):
	  term{anno*} -> alias-uri
	  where
	    <fetch-elem(?Scope(scope*))> anno*
	  ; ns        := <nabl-uri-namespace> def-uri
	  ; base-uri  := <lookup> (ns, scope*)
	  ; segment   := <nabl-uri-path; Hd> def-uri
	  ; alias-uri := <nabl-extend-uri(|segment); nabl-nonunique-uri> base-uri
	  where
	    new-alias(|partition, alias-uri, def-uri)
      
rules // generic analysis of uses
	
	nabl-use(|lang, partition, unique*, uri*, candidate):
		name{anno*} -> result
		with
		  candidate* := <is-list <+ MkSingleton> candidate;
			// generate a name if needed
			name' := <try(nabl-namegen(|lang, partition, unique*, uri*, anno*))> name
		where
			if inner-name := <not(is-string); nabl-get-name> name'; Use(inner-use-task) := <nabl-collect-use> inner-name then
				// Filter the inner use with properties instead of creating a new resolution task 
				subtask* := <map(nabl-filter-use-candidate(|lang, partition, uri*, inner-use-task))> candidate*;
				choice   := <task-create-choice(|partition)> subtask*;
			  u        := <new-use(|partition, choice)>;
			  <try(nabl-unresolved-task(|partition, choice))> inner-name; // TODO: this may result in multiple unresolved msgs.
			  // TODO: what about completions?
			  result := <nabl-name-apply(replace-annotations(?Use(_)|u))> name'
			else
				subtask* := <map(nabl-use-candidate(|lang, partition, uri*, <nabl-fix-name> name'))> candidate*;
				choice   := <task-create-choice(|partition)> subtask*;
			  u        := <new-use(|partition, choice)>;
			  <try(nabl-unresolved-task(|partition, choice))> name';
			  if <is-completion-name> name' then
			  	completion-subtask* := <mapconcat(nabl-completion-candidate(|lang, partition, uri*))> candidate*;
			  	completion-concat   := <task-create-combine(|partition)> completion-subtask*;
			  	result              := <replace-annotations(?Use(_)|[u, Completion(completion-concat)])> name'
			  else
			  	result := <replace-annotation(?Use(_)|u)> name'
		  	end
			end

	nabl-use-check-tasks(|ctx, ns) =
	   try(nabl-collect-use; ?Use(<id>))
	 ; nabl-create-checkdefs(|ctx, ns)

	// candidate in current scope
	nabl-use-candidate(|lang, ctx, uri*, name) =
	  ?UseCandidate(ns, prop*, Current(), _, _)
	;	<lookup-uri(|lang, ns)> uri*
  ; ![<try(nabl-uri-strip-barriers)>|<nabl-uri-parents(|ns)>]
  ; nabl-insert-import-tasks(|ctx, ns)
  ; nabl-resolve-task(|ctx, ns, <nabl-fix-name> name, prop*)
      
	// candidate in another scope (result of another resolution)	  
	nabl-use-candidate(|lang, ctx, uri*, name) =
		?UseCandidate(ns, prop*, Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), _, dep*)
	; if Result(_) := ctx-name then // result exists
	    !ctx-name
	  else // result will be created here
	    <nabl-use-candidate(|lang, ctx, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, True(), dep*)
	  end
	; MkSingleton
	; nabl-insert-import-tasks(|ctx, ns)
  ; nabl-resolve-task(|ctx, ns, <nabl-fix-name> name, prop*)
    // TODO: disambiguation
    // TODO: order of imported URI's is unclear
  		
	// filtering candidate in current scope
	nabl-filter-use-candidate(|lang, partition, uri*, use-task):
		UseCandidate(ns, prop*, Current(), _, _) -> check-task
		where
			constraint-task := <nabl-use-propconstraint(|partition)> (use-task, prop*);
			check-task      := <nabl-use-check-tasks(|partition, ns)> 

	// filtering candidate in another scope: ignore existing resolution  
	nabl-filter-use-candidate(|lang, partition, uri*, name):
		UseCandidate(_, _, Context(_, _, _, _), _, _) -> <nabl-use-candidate(|lang, partition, uri*, name)>

			
	nabl-use-propconstraint(|ctx):
		(task, [p@Prop(kind, expected, dep*)|rest]) -> rec
		where
			pc  := <nabl-create-propconstraint(|ctx, dep*, kind, task)> expected;
			rec := <nabl-use-propconstraint(|ctx)> (pc, rest)
			
	nabl-use-propconstraint(|ctx):
		(task, []) -> task

rules // completion

	// candidate in current scope
	nabl-completion-candidate(|lang, partition, uri*):
		UseCandidate(ns, prop*, Current(), wci, _) -> subtask*
		where
			uri       := <lookup-uri(|lang, ns)> uri*;
			subtask*  := <nabl-resolve-all-tasks(|partition, ns, prop*)> [uri|<nabl-uri-parents> uri]

	// candidate in another scope (result of resolution)	  
	nabl-completion-candidate(|lang, partition, uri*):
		UseCandidate(ns, prop*, c@Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), _, _) -> subtask*
		where
			ctx-result := <nabl-use-candidate(|lang, partition, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, True(), []);
	    subtask*   := <nabl-resolve-all-tasks(|partition, ns, prop*)> [ctx-result]

rules // filtering
	
	nabl-filter(|lang, partition, uri*, ctx-string, ctx-terms):
		name -> result
		where
		  defs-task   := <nabl-collect-use-task> name
		; filter-task := <nabl-create-filter(|partition, uri*, ctx-terms, ctx-string)> defs-task
		; result      := <replace-annotation(?Use(_)|Use(filter-task))> name
		 
rules // disambiguation
	
	nabl-disambiguate(|lang, partition, uri*, ctx-string, ctx-terms):
		name -> result
		where
		  defs-task   := <nabl-collect-use-task> name
		; disamb-task := <nabl-create-disambiguate(|partition, uri*, ctx-terms, ctx-string)> defs-task
		; result      := <replace-annotation(?Use(_)|Use(disamb-task))> name
		 
rules // generic analysis of imports
  
  nabl-import(|lang, partition, unique*, uri*, imports) =
    where(<map(nabl-import-candidate(|lang, partition, unique*, uri*))> imports)
  
  nabl-import-candidate(|lang, partition, unique*, uri*) =
    ?Single(ns, term, scope*, dep)
  ; Use(uri) := <nabl-collect-use> term
  ; name     := <nabl-get-name; nabl-fix-name> term
  ; <try-make-list; map(nabl-import-alias(|lang, partition, unique*, uri*, uri, ns, name))> scope*
  
  nabl-import-alias(|lang, partition, unique*, uri*, target-uri, ns, name):
    scope -> <new-alias(|partition, alias-uri, target-uri)>
  where
    base-uri  := <nabl-scope-uri(|lang, uri*, ns)> scope
    // TODO: uniqueness should be a property of the import, assumes non-unique right now.
  ; alias-uri := <nabl-extend-uri(|unique*, partition, ns, name, NonUnique())> base-uri


  nabl-import-candidate(|lang, partition, unique*, uri*) =
    ?Wildcard(import*, from, into, dep)
  ; <map(nabl-import-prop(|lang, partition, uri*, from, into))> import*
    
  nabl-import-prop(|lang, partition, uri*, from, into):
    Import(lang, ns) -> <new-prop(|partition, into-uri, Import(ns), from-uri)>
  where
     <not(?Imported(_))> ns
  where
    from-uri := <nabl-scope-uri(|lang, uri*, ns)> from 
  ; into-uri := <nabl-scope-uri(|lang, uri*, ns)> into
    
  nabl-import-prop(|lang, ctx, uri*, from, into):
    Import(lang, Imported(ns)) -> <new-prop(|ctx, into-uri, Import(ns), proplookup)>
  where
    from-uri := <nabl-scope-uri(|lang, uri*, ns)> from 
  ; into-uri := <nabl-scope-uri(|lang, uri*, ns)> into
  ; proplookup := <prop-create-lookup(|ctx, Import(ns)); task-create-insert(|ctx); task-create-combine(|ctx)> from-uri


  nabl-scope-uri(|lang, uri*, ns):
    Current() -> <lookup-uri(|lang, ns); nabl-uri-strip-barriers> uri*
  
  nabl-scope-uri(|lang, uri*, ns):
    DefScope(term{anno*}) -> <lookup; nabl-uri-strip-barriers> (ns, scope*)
    where
      <fetch-elem(?Scope(scope*))> anno*
      
  nabl-scope-uri(|lang, uri*, ns):
    Context(_, name, _, _) -> uri
    where
      Use(uri) := <nabl-collect-use> name
              
rules // name retrieval

  nabl-get-name = is-string
  
  nabl-name-apply(s) = is-string; s
    
  nabl-fix-name = try(fix-completion-name); strip-annos
  
rules // URI retrieval
  
  nabl-collect-def =
    try(nabl-get-name);
    get-annos;
    collect-one(?Def(_))
    
  nabl-collect-all-def =
    try(nabl-get-name);
    get-annos;
    collect-all(?Def(_))
    
  nabl-collect-use =
    try(nabl-get-name);
    get-annos;
    collect-one(?Use(_))

	nabl-collect-use-task =
    nabl-collect-use;
    ?Use(<id>)
    
  nabl-collect-all-use =
    try(nabl-get-name);
    get-annos;
    collect-all(?Use(_))
    
  nabl-collect-completion =
    get-annos;
    collect-one(?Completion(_))
    
  nabl-collect-all-completion =
    get-annos;
    collect-all(?Completion(_))

rules // helpers
	
	replace-scope-uri(|path) = foldl(update-scope-uri(!path|<nabl-uri-language> path))
  extend-scope-uri(s|lang) = foldl(update-scope-uri(s|lang))
  
	update-scope-uri(update|lang):
		(key, uri*) -> result
		where
		  result := <fetch((?key, update))> uri* 
		<+ 
		  result := [(key, <nabl-base-uri; update> lang)|uri*]
			  
	lookup-uri(|lang, ns) =
	  <lookup> (ns, <id>) <+ <nabl-base-uri> lang
 
  lookup-uri(|uri*) =
    <lookup> (<id>, uri*)

"

	create-nabl-complete = 
		<output-text-file(|["lib", "runtime", "nabl"], "complete.str")>
"module runtime/nabl/complete

imports
	
	runtime/nabl/collect
  runtime/nabl/uri
  runtime/task/core
  
signature

  constructors
    
    COMPLETION : String -> COMPLETION
    
rules // Code completion

  nabl-propose-completions:
    ast -> proposal*
    with
	    	completion* := <collect-one(?COMPLETION(_)); nabl-collect-all-completion> ast;
				def*        := <mapconcat(\\Completion(result) -> result\\; task-get-solved)> completion*;
				proposal*   := <map(nabl-uri; nabl-uri-name)> def*
			<+
				proposal*   := []

"

	create-nabl-constraints = 
		<output-text-file(|["lib", "runtime", "nabl"], "constraints.str")>
"module runtime/nabl/constraints

imports
  runtime/nabl/uri
  runtime/nabl/collect
  runtime/nabl/entries
  runtime/nabl/tasks
  runtime/task/core
  runtime/task/tasks
  runtime/properties/tasks
  
rules
  
  nabl-lookup-local(|ctx) =
    nabl-uri => uri
  ; nabl-uri-all-local-scopes
  ; nabl-resolve-task(|ctx, <nabl-uri-namespace> uri, <nabl-uri-name> uri, [])
  
  nabl-lookup-local(|ctx, ns) =
    nabl-uri => uri
  ; nabl-uri-all-local-scopes
  ; nabl-resolve-task(|ctx, ns, <nabl-uri-name> uri, [])
    
 nabl-lookup-local(|ctx, ns, name) =
    nabl-uri-all-local-scopes
  ; nabl-resolve-task(|ctx, ns, name, [])

rules
  
  nabl-lookup-lexical(|ctx) =
    nabl-uri => uri
  ; nabl-uri-all-lexical-scopes
  ; nabl-resolve-task(|ctx, <nabl-uri-namespace> uri, <nabl-uri-name> uri, [])
  
  nabl-lookup-lexical(|ctx, ns) =
    nabl-uri => uri
  ; nabl-uri-all-lexical-scopes
  ; nabl-resolve-task(|ctx, ns, <nabl-uri-name> uri, [])
    
 nabl-lookup-lexical(|ctx, ns, name) =
    nabl-uri-all-lexical-scopes
  ; nabl-resolve-task(|ctx, ns, name, [])
  
  nabl-lookup-lexical-parent(|ctx) =
    nabl-uri => uri
  ; nabl-uri-all-lexical-parent-scopes
  ; nabl-resolve-task(|ctx, <nabl-uri-namespace> uri, <nabl-uri-name> uri, [])
  
  nabl-lookup-lexical-parent(|ctx, ns) =
    nabl-uri => uri
  ; nabl-uri-all-lexical-parent-scopes
  ; nabl-resolve-task(|ctx, ns, <nabl-uri-name> uri, [])
    
 nabl-lookup-lexical-parent(|ctx, ns, name) =
    nabl-uri-all-lexical-parent-scopes
  ; nabl-resolve-task(|ctx, ns, name, [])
    
rules
  
  nabl-lookup-local-import(|ctx) =
    nabl-uri
  ; nabl-lookup-local-import(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
  
  nabl-lookup-local-import(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-local-import(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-local-import(|ctx, ns, name) =
    nabl-uri-parent
  ; prop-create-lookup(|ctx, Import(ns))
  ; nabl-create-resolvedefs(|ctx, ns, name, [])
  
rules
  
  nabl-lookup-lexical-import(|ctx) =
    nabl-uri
  ; nabl-lookup-lexical-import(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
  
  nabl-lookup-lexical-import(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-lexical-import(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-lexical-import(|ctx, ns, name) =
    nabl-uri-parents
  ; map(
    	prop-create-lookup(|ctx, Import(ns))
    ; nabl-create-resolvedefs(|ctx, ns, name, [])
    )
  ; task-create-choice(|ctx)
    
"

	create-nabl-entries = 
		<output-text-file(|["lib", "runtime", "nabl"], "entries.str")>
"module runtime/nabl/entries

imports
  
  runtime/nabl/collect
  runtime/nabl/utils
  runtime/nabl/uri
  runtime/nabl/resolve
  runtime/index/core
  runtime/editor/origins
  
signature

  constructors
    
    Def          : URI                    -> Entry
    Alias        : URI * URI              -> Entry
    InverseAlias : URI * URI              -> Entry
    Use          : Result                 -> Entry

rules // Index entries to diff for incrementality
  
  nabl-diff-entry = ?Def(_)
  
  nabl-diff-entry = ?Alias(_, _)
 
rules
  
  new-def(|partition, uri):
    x -> definition
    with
      definition := <origin-track-forced(!Def(uri))> x;
      <index-add(|partition)> definition;
			<new-alias(|partition, <nabl-nonunique-uri> uri, uri)> x
      
  new-alias(|partition, uri, alias-uri):
    x -> alias
    with
      alias := <origin-track-forced(!Alias(uri, alias-uri))> x;
      ialias := <origin-track-forced(!InverseAlias(alias-uri, uri))> x;
      if <not(eq)> (uri, alias-uri) then
      	<index-add(|partition)> alias;
      	<index-add(|partition)> ialias
      end

  new-use(|partition, uri):
    x -> use
    with
      use := <origin-track-forced(!Use(uri))> x;
      <index-add(|partition)> use

rules // index uri & value projections
  
  /** @internal */
  nabl-uri:
    Def(uri) -> uri

  /** @internal */
  nabl-uris:
    Def(uri) -> [uri]
    
  /** @internal */
  nabl-uri:
    Alias(uri, _) -> uri
    
  /** @internal */
  nabl-uris:
    Alias(uri, _) -> [uri]
    
  /** @internal */
  nabl-uri:
    InverseAlias(uri, _) -> uri
    
  /** @internal */
  nabl-uris:
    InverseAlias(uri, _) -> [uri]
    
  /** @internal */  
  nabl-uri:
    Use(uri) -> <nabl-collect-one-resolved-def; nabl-uri> uri
    
  /** @internal */  
  nabl-uris:
    Use(uri) -> <nabl-collect-all-resolved-defs; map(nabl-uri)> uri
    
  /** @internal */
  nabl-value:
    Def(value) -> value
    
  /** @internal */
  nabl-values:
    Def(value) -> [value]
    
  /** @internal */
  nabl-value:
    Alias(_, value) -> value
    
  /** @internal */
  nabl-values:
    Alias(_, value) -> [value]
    
  /** @internal */
  nabl-value:
    InverseAlias(_, value) -> value
    
  /** @internal */
  nabl-values:
    InverseAlias(_, value) -> [value]

  /** @internal */
  nabl-value:
    Use(value) -> <nabl-uri>
    
  /** @internal */
  nabl-values:
    Use(value) -> <nabl-uris>

"

	create-nabl-incremental = 
		<output-text-file(|["lib", "runtime", "nabl"], "incremental.str")>
"module nbl/incremental

imports
	
	runtime/nabl/uri
	runtime/nabl/interface
	runtime/task/core
	
rules // Read generation
	
	nabl-add-uri-read(|taskID):
		uri -> uri
		with
			<try(nabl-replace-uri-qualifier(|())); task-add-read(|taskID)> uri
			
	nabl-add-ns-read(|taskID, ns):
		uri -> uri
		with
			<task-add-read(|taskID)> (uri, ns)
			
	nabl-add-name-read(|taskID, ns, name):
		uri -> uri
		with
			<nabl-extend-uri(|ns, name, ()); task-add-read(|taskID)> uri
			
rules // Read processing
	
	nabl-get-changed-reads:
		changed-entry* -> [uri-read*, ns-read*]
		with
			uri*      := <filter(nabl-diff-entry; nabl-uri)> changed-entry*;
			uri-read* := <map(try(nabl-replace-uri-qualifier(|())))> uri*;
			ns-read*  := <filter(nabl-create-ns-read)> uri*
	
	nabl-create-ns-read:
		uri -> (uri', ns)
		where
			ns   := <nabl-uri-namespace> uri;
			uri' := <nabl-uri-parent> uri

"

	create-nabl-interface = 
		<output-text-file(|["lib", "runtime", "nabl"], "interface.str")>
"module runtime/nabl/interface

strategies // Collect
  
  nabl-collect-rewrite(|lang, partition, old-uri*, new-uri*) = fail
  
	nabl-scoping-site = fail
  
  nabl-new-scoping-site = fail
  
	nabl-def-site(
	  child-uris, sibiling-uris, implicits
	| lang, partition, unique*, uri*, state*
	) = fail
	
	nabl-external-def-site(|lang, partition, unique*, uri*, state*, implicit*) = fail

	nabl-state-site = fail
	
	nabl-use-site(|lang, partition, unique*, uri*, state*) = fail
	
	nabl-filtering-site(|lang, partition, unique*, uri*, state*) = fail
	
	nabl-disambiguation-site(|lang, partition, unique*, uri*, state*) = fail
	
	nabl-import-site(|lang, partition, unique*, uri*, state*) = fail
	
	nabl-prop-site(|lang, partition, uri*, state*, implicit*) = fail
	
strategies // Projections
  
	nabl-get-name = fail
	
	nabl-name-apply(s) = fail
	
strategies // Lookup hooks
		
	nabl-filter-def(|ctx, uri*, ctx-terms, ctx-string) = fail
	
	nabl-disambiguate-def(|ctx, uri*, ctx-terms, ctx-string) = fail

strategies // Name generation
	
	nabl-namegen-name(|lang, partition, uri, ns) = fail
	
strategies // Default error checks
	
	nabl-check-disable-unresolved = fail
	
	nabl-check-disable-duplicate(|uri, ns) = fail
	
	nabl-check-disable-hiding(|uri, ns) = fail
	
strategies // Incrementality
	
	nabl-diff-entry = fail
	
"

	create-nabl-lookup = 
		<output-text-file(|["lib", "runtime", "nabl"], "lookup.str")>
"module runtime/nabl/lookup

imports
  
	runtime/nabl/query
	runtime/nabl/uri
	runtime/nabl/collect
  runtime/properties/query
  runtime/task/core

rules // Lookup
	
	nabl-lookup(|ns, name):
		uri -> def*
		with
  		uri' := <nabl-extend-uri(|ns, name, NonUnique())> uri;
  		def* := <nabl-get-all-definitions> uri'

	nabl-lookup-all(|ns):
		uri -> def*
		with
  		def*  := <nabl-get-child-definitions(|ns)> uri

"

	create-nabl-namegen = 
		<output-text-file(|["lib", "runtime", "nabl"], "namegen.str")>
"module nbl/namegen

imports
	
	runtime/nabl/collect
	runtime/nabl/query
	runtime/nabl/uri
	runtime/nabl/utils
	runtime/nabl/interface
	runtime/editor/origins
	runtime/editor/annotations
	runtime/index/core
	runtime/index/query
	
signature

	constructors
		
		GenerateName : Namespace -> GenerateName
		GenerateNum  : URI * Int -> Entry
	
rules
	
	nabl-namegen-stem(|ns) = add-annotation(|GenerateName(ns))

rules // Name generation
	
	nabl-namegen(|lang, partition, unique*, uri*, anno*):
		name -> <origin-track-forced(!newname{anno'*})> name
		where
			<get-annotation(?GenerateName(ns))> name;
			uri      := <lookup-uri(|lang, ns)> uri*;
			newname  := <nabl-namegen-get(|lang, partition, ns, uri, unique*)> name;
			anno'*   := <remove-all(?GenerateName(_))> anno*
	
	nabl-namegen-get(|lang, partition, ns, uri, unique*):
		name -> result
		with
			name-key := (name, \"namegen\");
      if full-newname := <hashtable-get(|name-key)> unique* then
        result := full-newname
      else
        nextnum := <nabl-namegen-get-num(|uri) <+ !0>;
        numstr  := <int-to-string> nextnum;
        newname := <nabl-namegen-name-create(|lang, partition, uri, ns)> numstr;
        result  := $[[newname][numstr]];
        <hashtable-put(|name-key, result)> unique*;
        <inc; nabl-namegen-store-num(|partition, uri)> nextnum
      end

rules // Name generation strategies
      
  nabl-namegen-name-create(|lang, partition, uri, ns) = 
  	nabl-namegen-name(|lang, partition, uri, ns) <+ nabl-namegen-name-generic(|lang, partition, uri, ns)
      
  nabl-namegen-name-generic(|lang, partition, uri, ns):
  	name -> <nabl-namegen-name-generic-fix> 
			$[[<nabl-namegen-name-generic-str> lang-name][<nabl-namegen-name-generic-str> partition][ns-name][uri-name][name]]
  	with
  		Language(lang-name) := lang;
  		ns-name             := <get-constructor; nabl-namegen-name-generic-str> ns;
  		uri-name            := <nabl-uri-path; filter(nabl-segment-name; nabl-namegen-name-generic-str); concat-strings> uri
  
  nabl-namegen-name-generic-str = 
  	explode-string; reverse; (take(|3) <+ take(|2) <+ take(|1) <+ ![]); reverse; implode-string
  		
	nabl-namegen-name-generic-fix = 
		lower-case; string-replace(|\"/\", \"_\"); string-replace(|\"-\", \"_\"); string-replace(|\".\", \"_\")

rules // Storage & retrieval
	
	nabl-namegen-get-num(|uri)              = <nabl-get-all-values; !(<id>, 0); foldl(max)> GenerateNum(uri, ())
	nabl-namegen-store-num(|partition, uri) = <index-add(|<nabl-namegen-partition(|partition)>)> GenerateNum(uri, <id>)
	nabl-namegen-clear(|partition)          = nabl-namegen-partition(|partition); index-clear-partition
	nabl-namegen-partition(|partition)      = !$[[partition]_namegen]
	nabl-uri                                : GenerateNum(uri, _) -> uri
	nabl-value                              : GenerateNum(_, num) -> num
	
"

	create-nabl-query = 
		<output-text-file(|["lib", "runtime", "nabl"], "query.str")>
"module runtime/nabl/query

imports
  
  runtime/nabl/uri
  runtime/nabl/entries
  runtime/index/query
  runtime/task/core
  runtime/task/insert
  
rules // Specific queries

  /**
   * Gets all unique and non-unique definition entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-definitions> [Entity(), \"M\", \"Bar\"] => [Def([Entity(), \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
   */
  nabl-get-all-definitions:
    contains-uri* -> <mapconcat(nabl-get-unique-nonunique(!Def(<id>)))> uri*
    where
    	uri* := <nabl-uris> contains-uri*
    	
  /**
   * Gets all child definition entries in given URI that match given namespace.
   *
   * Example:
   *   <nabl-get-child-definitions> [Entity(), \"M\", \"Bar\"] => [Def([Field(), \"a\", \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
   */
  nabl-get-child-definitions(|ns):
    contains-uri* -> def*
    where
    	uri* := <nabl-uris> contains-uri*;
    	def* := <mapconcat(!Def(<id>); nabl-get-children(|ns)); mapconcat(nabl-uri; nabl-get-unique-nonunique(!Def(<id>)))> uri*

  /**
   * Gets all Use entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-uses> Def([Entity(), \"M\", \"Bar\"]) => [Use([Entity(), \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Use(uri))
   */
  nabl-get-all-uses:
    containsURI -> <nabl-get-all> Use(uri)
    where
    	uri := <nabl-uri> containsURI

  /**
   * Gets all Alias entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-aliases> Def([Entity(), \"M\", \"Bar\"]) => [[Entity(), \"M\", \"Baz\"], ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(aliasURI)
   */
  nabl-get-all-aliases:
    contains-uri* -> alias-uri*
    where
    	uri*           := <nabl-uris> contains-uri*;
    	nonunique-uri* := <filter(nabl-replace-uri-qualifier(|NonUnique()))> uri*;
      alias-uri*     := <mapconcat(!Alias(<id>, ()); nabl-get-all-values)> nonunique-uri*
      
  /**
   * Gets all InverseAlias entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-aliases> Def([Entity(), \"M\", \"Bar\"]) => [[Entity(), \"M\", \"Baz\"], ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(inverseAliasURI)
   */
  nabl-get-all-inverse-aliasses:
    contains-uri* -> inverse-alias*
    where
    	uri*           := <nabl-uris> contains-uri*;
      inverse-alias* := <mapconcat(!InverseAlias(<id>, ()); nabl-get-all-values)> uri*

rules // Generic queries
  
  nabl-get-all:
    template -> <index-get-all> template
       
  nabl-get-all-values:
    template -> <nabl-get-all; map(nabl-value)> template

  nabl-get:
    template -> <nabl-get-all; Hd> template
     
  nabl-get-value:
    template -> <nabl-get-all; Hd; nabl-value> template
  
  nabl-get-children:
    template -> entries
      with
        entries  := <index-get-children> template

  nabl-get-children(|namespace):
    template -> entries
      with
        children := <index-get-children> template;
        entries  := <nabl-filter-entries(|namespace)> children
        
  nabl-get-children(|namespace, prefix):
    template -> entries
      with
        children := <index-get-children> template;
        entries  := <nabl-filter-entries(|namespace, prefix)> children

  nabl-get-unique-nonunique(create-template):
  	uri -> [unique*, non-unique*]
  	where
      if alias* := <nabl-get-all-aliases> uri then
      	// HACK: handle Result terms on the resulting URI of an alias. this should be decomposed into a task?
      	(alias-result*, alias-uri*) := <partition(?Result(_); insert-results-or-delay)> alias*;
      	unique-uri*                 := <mapconcat(create-template; nabl-get-all)> alias-uri*;
      	unique-result*              := <try(concat)> alias-result*;
      	unique*                     := [unique-uri*, unique-result*]
      else
        unique* := []
      end;
      if non-unique-uri := <nabl-replace-uri-qualifier(|NonUnique())> uri then
        non-unique* := <create-template; nabl-get-all> non-unique-uri
      else
        non-unique* := []
      end

rules /** @internal Entry filtering */
  
  /** @internal */
  nabl-filter-entries(|namespace, prefix):
    entry* -> <filter(nabl-compare-prefix(|namespace, prefix))> entry*
  
  /** @internal */
  nabl-filter-entries(|namespace):
    entry* -> <filter(nabl-compare-namespace(|namespace))> entry*

rules /** @internal Helpers */
  
  /** @internal */
  nabl-compare-prefix(|namespace, prefix):
    entry -> <id>
    where
      uri := <nabl-uri> entry;
      <eq> (namespace, <nabl-uri-namespace> uri);
      <is-substring(!prefix)> <nabl-uri-name> uri
      
  /** @internal */
  nabl-compare-namespace(|namespace):
    entry -> <id>
    where
      uri := <nabl-uri> entry;
      <eq> (namespace, <nabl-uri-namespace> uri)

"

	create-nabl-resolve = 
		<output-text-file(|["lib", "runtime", "nabl"], "resolve.str")>
"module runtime/nabl/resolve

imports
  
  runtime/nabl/tasks
	runtime/nabl/entries
	runtime/task/core
	runtime/task/insert
  runtime/task/utils
  
rules // Reference resolution
  
  nabl-is-reference =
    ?Use(_)
    
  nabl-has-reference =
    collect-one(nabl-is-reference)
    
  nabl-has-reference =
    has-annos;
    get-annos;
    nabl-has-reference
  
	nabl-collect-all-resolved-defs:
		ast -> def*
		with
			if ast' := <insert-results-or-delay> ast then
				def* := <collect-all-annos(?Def(_), conc)> ast'
			else
				def* := []
			end

	nabl-collect-one-resolved-def =
		insert-results-or-delay;
		collect-one-annos(?Def(_))

"

	create-nabl-tasks = 
		<output-text-file(|["lib", "runtime", "nabl"], "tasks.str")>
"module runtime/nabl/tasks

imports 
  
  runtime/task/core
  runtime/task/create
  runtime/task/insert
  runtime/task/tasks
  runtime/task/utils
  runtime/nabl/lookup
  runtime/nabl/collect
  runtime/nabl/query
  runtime/nabl/incremental
  runtime/nabl/interface
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/nabl/entries
  runtime/properties/entries
  runtime/properties/eq
  runtime/properties/query
  runtime/properties/tasks
  
signature
  
  constructors
    
    CollectDefs            : Term                                      -> Instruction
    ResolveDefs            : Scope * Namespace * Name * Prop           -> Instruction
    ResolveAllDefs         : Scope * Namespace                         -> Instruction
    ResolveAllDefs         : Scope * Namespace * Name * Prop           -> Instruction
    CheckDefs              : Namespace * URI                           -> Instruction
    PropConstraint         : Kind * Expected * Result                  -> Instruction
    SubURI                 : Namespace * URI                           -> Instruction
    
    FilterDefsHigherOrder        : List(Def) * List(Term) * List(Term) * String -> Instruction
    FilterDefs                   : List(DefTuple)                               -> Instruction
    
    DisambiguateDefsHigherOrder  : List(Def) * List(Term) * List(Term) * String -> Instruction
    DisambiguateDefs             : List(DefTuple)                               -> Instruction
    
rules // Collects all definitions in a term
  
  nabl-create-collectdefs(|ctx):
  	term -> <new-task(|ctx)> CollectDefs(term)

  nabl-create-collectdefs(|ctx, dep*):
  	term -> <new-task(|ctx, all-dep*)> CollectDefs(term)
  	with 
    	all-dep* := <merge-dependencies(|dep*)> term
    	
  // todo: lift nabl-get-name to task creation, currently storing an AST in task (expensive storage!)
  	
  perform-task(|nr): 
    CollectDefs(term) -> <?Def(_) <+ (try(nabl-get-name); get-annos; fetch(?Def(_) + ?Use(<id>)))> term 

rules // Resolve definitions in a scope of a certain namespace and name (stops when definitions are found in a scope)
  
  nabl-create-resolvedefs(|ctx, ns, name, prop*):
  	scope -> <new-task(|ctx)> ResolveDefs(scope, ns, name, prop*)

  
  perform-task(|task-id):
  	ResolveDefs(scope, ns, name, prop*) -> result
  	where
  		uri    := <nabl-uri> scope;
  		name'  := <try-remove-list; strip-annos> name;
  		<nabl-add-name-read(|task-id, ns, name')> uri;
  		def*   := <nabl-lookup(|ns, name')> uri;
  		result := <filter(filter-defs-props(|prop*)); not(?[])> def*
  		
	task-short-circuit = ?ResolveDefs(_, _, _, _)

rules // Resolve all definitions in a scope of a certain namespace and name
	
	// TODO: This seems to be redundant, given the perform-task rule
  nabl-create-resolvealldefs(|ctx, ns, name, prop*):
  	scope -> <new-task(|ctx)> ResolveAllDefs(scope, ns, name, prop*)
  
  
  perform-task(|nr):
    ResolveAllDefs(scope, ns, name, prop*) -> <perform-task(|nr)> ResolveDefs(scope, ns, name, prop*)

rules // Resolve all definitions in a scope of a certain namespace

  nabl-create-resolvealldefs(|ctx, ns):
  	scope -> <new-task(|ctx)> ResolveAllDefs(scope, ns)
	
  perform-task(|nr):
  	ResolveAllDefs(scope, ns) -> def*
  	where
  		uri  := <nabl-uri> scope;
  		<nabl-add-ns-read(|nr, ns)> uri;
  		def* := <nabl-lookup-all(|ns)> uri;
  		not(?[])

  // inserts wildcard import resolution tasks into a list of scope URIs
  // each scope URI is wrapped in a list, 
  // followed by the result of a wildcard import resolution task for this URI
  nabl-insert-import-tasks(|ctx, ns) =
    map(try(nabl-uri-strip-barriers))
  ; mapconcat(
      ![ <try(nabl-is-uri; MkSingleton)>
       , <prop-create-lookup(|ctx, Import(ns)); task-create-insert(|ctx); task-create-combine(|ctx)>
       ]
    )
    // TODO: order of imported URI's is unclear
 
  // creates a short-circuit resolution task for a list of scope URIs
  nabl-resolve-task(|ctx, ns, name, prop*) =
    task-create-combine(|ctx) 
  ; nabl-create-resolvedefs(|ctx, ns, name, prop*)
    // TODO: disambiguation
 
  // creates a full resolution task for a list of scope URIs
  nabl-resolve-all-task(|ctx, ns, name, prop*) =
    task-create-combine(|ctx) 
  ; nabl-create-resolvealldefs(|ctx, ns, name, prop*)
    // TODO: disambiguation
  
  // TODO: implement in same style as named version
	nabl-resolve-all-tasks(|partition, ns, prop*) =
		map(
		  <new-task(|partition)> ResolveAllDefs(<id>, ns)
		; <nabl-use-propconstraint(|partition)> (<id>, prop*)
		)
			
rules // Check if a definition is in given namespace

  nabl-create-checkdefs(|ctx, ns):
  	definition -> <new-task(|ctx)> CheckDefs(ns, definition)

		
	perform-task(|nr):
		CheckDefs(ns, d) -> d
		where
			<nabl-uri; nabl-uri-namespace; ?ns> d

rules // Filter definitions by properties
  		
	filter-defs-props(|prop*):
		definition -> <map(filter-defs-prop(|definition)); !definition> prop*
	 	
	filter-defs-prop(|definition):
		Prop(kind, expected, _) -> definition
		where
			uri    := <nabl-uri> definition;
      value  := <get-index-property(|kind)> uri;
      value' := <insert-results-or-delay> value;
      <filter-defs-prop-eq(|expected, value')> kind

	filter-defs-prop-eq(|expected, value):
		kind -> <nabl-property-eq> (kind, Eq(), (expected, value))
		
	filter-defs-prop-eq(|expected, value):
		kind -> <nabl-property-eq> (kind, Eq(), (expected, <try-remove-list> value))
	
	
  nabl-create-propconstraint(|ctx, kind, definition):
  	expected -> <new-task(|ctx)> PropConstraint(kind, expected, definition)
  	
	nabl-create-propconstraint(|ctx, dep*, kind, definition):
  	expected -> <new-task(|ctx, all-dep*)> PropConstraint(kind, expected, definition)
  	with 
    	all-dep* := <merge-dependencies(|dep*)> (kind, expected, definition)
	

	perform-task(|task-id):
		PropConstraint(kind, expected, definition) -> <filter-defs-prop(|definition)> Prop(kind, expected, [])

rules // URI manipulation
	
	nabl-create-suburi(|ctx, namespace):
		contains-uri -> <new-task(|ctx)> SubURI(namespace, contains-uri)
		
	perform-task(|task-id):
		SubURI(namespace, contains-uri) -> <nabl-sub-uri(|namespace)> uri
		where
			uri := <nabl-uri> contains-uri

rules // Filtering

	nabl-create-filter(|ctx, uri*, ctx-terms, ctx-string):
		defs -> <new-task(|ctx)> FilterDefsHigherOrder(defs, uri*, ctx-terms, ctx-string)
	
	task-is-combinator = ?FilterDefsHigherOrder(_, _, _, _)
	task-is-higherorder = ?FilterDefsHigherOrder(_, _, _, _)
	
	perform-task(|task-id):
		FilterDefsHigherOrder(def*, uri*, [ctx-terms], ctx-string) -> FilterDefs(def-tuple*)
		where
			def-tuple* := <filter(nabl-filter-def(|task-id, uri*, ctx-terms, ctx-string))> def*


	task-is-combinator = ?FilterDefs(_)
	
	perform-task(|task-id):
		FilterDefs(def-tuple*) -> <filter(not(?(_, [])))> def-tuple*
		
rules // Disambiguation

	nabl-create-disambiguate(|ctx, uri*, ctx-terms, ctx-string):
		defs -> <new-task(|ctx)> DisambiguateDefsHigherOrder(defs, uri*, ctx-terms, ctx-string)
	
	task-is-combinator = ?DisambiguateDefsHigherOrder(_, _, _, _)
	task-is-higherorder = ?DisambiguateDefsHigherOrder(_, _, _, _)
	
	perform-task(|task-id):
		DisambiguateDefsHigherOrder(def*, uri*, [ctx-terms], ctx-string) -> DisambiguateDefs(def-tuple*)
		where
			def-tuple* := <filter(nabl-disambiguate-def(|task-id, uri*, ctx-terms, ctx-string))> def*


	task-is-combinator = ?DisambiguateDefs(_)
	
	// TODO: this task is not generic enough yet, it currently assumes minimization.
	perform-task(|task-id):
		DisambiguateDefs(def-tuple*) -> def-sorted2*
		where
		  def-sorted1* := <sort-list(LSort(\\((_, [x]), (_, [y])) -> <gt> (x, y)\\))> def-tuple*
		; def-sorted2* := <take-while(?(_, x)); map(Fst)> def-sorted1* // Take all defs with the same distance.
		
"

	create-nabl-uri = 
		<output-text-file(|["lib", "runtime", "nabl"], "uri.str")>
"module runtime/nabl/uri

imports
  
  runtime/index/core
  runtime/editor/annotations
  runtime/nabl/interface
  runtime/nabl/query
  
signature

  sorts
  
    Language
    Segment
    Qualifier
    
  constructors
    
    Language    : String                       -> Language
    ID          : Namespace * Name * Qualifier -> Segment
    Subsequent  : String                       -> Segment
    Anonymous   : String                       -> Segment
    Unique      : String                       -> Qualifier
    NonUnique   :                                 Qualifier
    Unique      :                                 Qualifier
    URI         : Language * List(Segment)     -> URI
    Barrier     : List(Namespace)              -> Annotation
    
rules // Construction
  
  nabl-base-uri = 
    !URI(<id>, [])
     
  nabl-extend-uri(|segment) = 
    URI(id, ![segment|<id>])
    
  nabl-extend-uri(|namespace, name, qualifier) = 
    URI(id, ![ID(namespace, name, qualifier)|<id>])
    
  nabl-replace-uri(|segment) = 
    URI(id, [!segment|id])
    
  nabl-replace-uri(|namespace, name, qualifier) = 
    URI(id, [!ID(namespace, name, qualifier)|id])
    
  nabl-replace-uri-qualifier(|qualifier) =
    URI(id, [ID(id, id, !qualifier)|id])
      
  nabl-nonunique-uri =
		URI(id, [ID(id, id, !NonUnique())|id])
		
	nabl-uri-add-barriers(|namespace*):
		URI(lang, [seg|s]) -> URI(lang, [<replace-annotation(?Barrier(_)|new-barrier)> seg|s])
		where
			existing-namespace* := <get-annotation(?Barrier(<id>)) <+ ![]> seg;
			new-barrier         := Barrier([existing-namespace*, namespace*])
			
	nabl-uri-strip-barriers = 
		URI(id, map(remove-annotations(?Barrier(_))))
		
rules // Stable URI extensions
  
  nabl-extend-uri(|table, partition, ns, n, u):
    uri -> <nabl-extend-uri(|ns, n, qualifier)> uri
    where 
	    if where(<?NonUnique()> u) then
	      qualifier := NonUnique()
	    else
	      qualifier := Unique(<stable-uri-part(|table, partition)> (partition, uri, ns, n))
	    end
    
  nabl-extend-uri-anonymous(|table, partition):
    uri -> <nabl-extend-uri(|Anonymous(unique))> uri
    where
      unique := <stable-uri-part(|table, partition)> (partition, uri, \"anonymous\")
      
  nabl-extend-uri-subsequent(|table, partition):
    uri -> <nabl-extend-uri(|Subsequent(unique))> uri
    where
      unique := <stable-uri-part(|table, partition)> (partition, uri, \"subsequent\")

  stable-uri-part(|table, partition):
    key -> $[[partition]/[unique]]
    where
      if value := <hashtable-get(|key)> table then
        unique    := <int-to-string> value;
        new-value := <inc> value
      else
        unique    := \"0\";
        new-value := 1
      end;
      <hashtable-put(|key, new-value)> table
      
rules // Projections
  
  nabl-uri = fail
  nabl-uris = fail
  nabl-value = fail
  nabl-values = fail
  
  nabl-uri-language:
    URI(language, _) -> language
    
  nabl-uri-language-name:
    URI(Language(name), _) -> name
    
  nabl-uri-path:
    URI(_, path) -> path
        
  nabl-uri-name:
    uri -> <nabl-uri-path; Hd; nabl-segment-name> uri
    
  nabl-uri-namespace:
    uri -> <nabl-uri-path; Hd; nabl-segment-namespace> uri    

  nabl-uri-qualifier:
    uri -> <nabl-uri-path; Hd; nabl-segment-qualifier> uri
    
  nabl-uri-barriers:
  	uri -> <nabl-uri-path; Hd; nabl-segment-barriers> uri
      
  nabl-segment-namespace:
    ID(namespace, _, _) -> namespace
    
  nabl-segment-name:
    ID(_, name, _) -> name
    
  nabl-segment-name:
  	Subsequent(name) -> name
  
	nabl-segment-name:
  	Anonymous(name) -> name
  	
	nabl-segment-qualifier:
    ID(_, _, qualifier) -> qualifier
    
  nabl-segment-barriers:
  	segment -> namespace*
  	where
  		Barrier(namespace*) := <get-annotation(?Barrier(_))> segment 
   
  nabl-closure(s) = 
      s 
    < ![<id>|<nabl-closure(s)>] 
    + ![]

rules // query scope URIs
  
  // TODO: where should we strip barriers here?
  nabl-uri-parent  = URI(id, Tl)
  nabl-uri-parents = nabl-closure(nabl-uri-parent)
      
  nabl-uri-parents(|target-ns):
    uri -> parent*
    where
      barrier-ns* := <nabl-uri-barriers <+ ![]> uri;
      if <not(elem)> (target-ns, barrier-ns*); parent := <nabl-uri-parent> uri then
        // Strip barriers from parent because URI's in the index also do not have barriers (matching would fail).
        parent* := [<nabl-uri-strip-barriers> parent|<nabl-uri-parents(|target-ns)> parent]
      else
        parent* := [] 
      end
  
  //  maps a list of definition URIs to a list of local scope URIs
  nabl-uri-local-scopes =
    ![<nabl-uri-parent>]
  
  // maps a list of definition URIs to a list of lexical scope URIs (including local scope)
  nabl-uri-lexical-scopes =
    nabl-uri-parents
    
  // maps a list of definition URIs to a list of lexical scope URIs (excluding local scope)
  nabl-uri-lexical-parent-scopes =
    nabl-uri-parent; nabl-uri-parents
  
  // maps a list of external definition URIs to a list of local scope URIs
  nabl-uri-external-scopes =
    nabl-get-all-inverse-aliasses
  ; map(nabl-uri-parent)
  
  // maps a list of external definition URIs to a list of lexical scope URIs (including local scope)
  nabl-uri-external-lexical-scopes =
    nabl-get-all-inverse-aliasses
  ; mapconcat(nabl-uri-lexical-scopes)
  
  // maps a list of external definition URIs to a list of lexical scope URIs (excluding local scope)
  nabl-uri-external-lexical-parent-scopes =
    nabl-get-all-inverse-aliasses
  ; mapconcat(nabl-uri-lexical-parent-scopes)
  
  nabl-uri-all-local-scopes =
    <conc> (<nabl-uri-local-scopes>, <nabl-uri-external-scopes>)
    
  nabl-uri-all-lexical-scopes =
    <conc> (<nabl-uri-lexical-scopes>, <nabl-uri-external-lexical-scopes>)
  
  nabl-uri-all-lexical-parent-scopes =
    <conc> (<nabl-uri-lexical-parent-scopes>, <nabl-uri-external-lexical-parent-scopes>)
    
	nabl-sub-uri(|namespace):
		uri -> <nabl-uri-strip-barriers> uri
		where
			nabl-uri-namespace => namespace
		
	nabl-sub-uri(|namespace):
		uri -> <nabl-uri-parent; nabl-sub-uri(|namespace); nabl-uri-strip-barriers> uri
		where
			not(nabl-uri-namespace => namespace)
    
rules // Conditions
  
  nabl-is-uri =
  	?URI(_, _)
  
  nabl-is-unique =
    nabl-uri-qualifier;
    ?Unique(_)
    
  nabl-is-nonunique =
    nabl-uri-qualifier;
    ?NonUnique()
    
  nabl-segment-is-id =
  	?ID(_, _, _)

rules // Equality
  
  nabl-uri-eq = 
    ?(URI(lang1, segs1), URI(lang2, segs2));
    <eq> (lang1, lang2);
    <zip(nabl-uri-segment-eq)> (segs1, segs2)
    
  nabl-uri-segment-eq =
    ?(ID(ns1, name1, _), ID(ns2, name2, _));
    <eq> (ns1, ns2);
    <eq> (name1, name2)
     
  nabl-uri-segment-eq =
    ?(Subsequent(_), Subsequent(_))
    
  nabl-uri-segment-eq =
    ?(Anonymous(_), Anonymous(_))
    
  nabl-uri-namespace-eq(|namespace) =
  	nabl-uri-namespace; ?namespace
    
rules // Printing
  
  nabl-print-uri:
    uri -> $[[ns] [names]]
    where
      ns#(_) := <nabl-uri-namespace> uri;
      names  := <nabl-uri-path; filter(nabl-segment-name); separate-by(|\".\"); concat-strings> uri
        
rules /** @internal Projections */

  /** @internal */
  nabl-uri:
    URI(_, _) -> <id>
    
  /** @internal */
  nabl-value:
    URI(_, _) -> <id>
 
  /** @internal */
  nabl-uris:
    URI(_, _) -> [<id>]
    
  /** @internal */
  nabl-values:
    URI(_, _) -> [<id>]

    
  /** @internal */  
  nabl-uri =
  	has-annos;
  	get-annos;
  	fetch-elem(nabl-uri)

  /** @internal */  
  nabl-value =
  	has-annos;
  	get-annos;
  	fetch-elem(nabl-value)

  /** @internal */  
  nabl-uris =
  	has-annos;
  	get-annos;
  	filter(nabl-uri)

  /** @internal */  
  nabl-values =
  	has-annos;
  	get-annos;
  	filter(nabl-value)

"

	create-nabl-utils = 
		<output-text-file(|["lib", "runtime", "nabl"], "utils.str")>
"module runtime/nabl/utils

imports
	
	libstratego-lib
	libstratego-aterm
	libstratego-gpp
	runtime/task/core
	runtime/editor/annotations

rules 
	
	match(m|val) = where (!val; m)
	
	vdebug(s) = where(verbose < debug(s) + id)
	verbose   = fail

	is-completion-name = ?\"completion123\"
  fix-completion-name = is-completion-name; !\"\"
  
  measure-time(s, log, match) =
    where(before := <times>);
    s;
    where(after := <times>; !(after, before); diff-times; times-to-seconds; Fst; match; log)
  
  measure-time(s, log | name) = 
    measure-time(s, record-time(|name); log, id)
    
  measure-time(s, log, match | name) = 
    measure-time(s, record-time(|name); log, match)
  
  record-time(|name) = id
  	
 	try-make-list = is-list <+ ![<id>]
		
	try-remove-list = is-list < Hd + id
	
	// @deprecated use runtime/editor/annotations get-annotation(s)
	has-annotation(s) = get-annotation(s)
	
rules // multimap simulation
	
	hash-multimap-put(|key, value):
		hashtable -> hashtable
		where
			values := <hash-multimap-getorcreate(|key)> hashtable;
			<hashtable-put(|key, [value|values])> hashtable 
			
	hash-multimap-putlist(|key, put-value*):
		hashtable -> hashtable
		where
			value* := <hash-multimap-getorcreate(|key)> hashtable;
			<hashtable-put(|key, [value*, put-value*])> hashtable 
			
	hash-multimap-getorcreate(|key) =
		hashtable-get(|key) <+ hashtable-put(|key, []); ![]
	
	hash-multimap-copy(|from):
		to -> to
		where
			// wtf is this I don't even.. hashtable-fold needs term arguments instead of current term arguments.
			<hashtable-fold(hash-multimap-copy-fold|to)> from
			
	hash-multimap-copy-fold(|key, value*):
		to -> <hash-multimap-putlist(|key, value*)> to

rules // Debugging
	
	debug(|t) = where(write-to-string; debug(!t))
	
	debug0 = debug(|\"0 \")
	debug1 = debug(|\"1 \")
	debug2 = debug(|\"2 \")
	debug3 = debug(|\"3 \")
	debug4 = debug(|\"4 \")
	debug5 = debug(|\"5 \")
	debug6 = debug(|\"6 \")
	debug7 = debug(|\"7 \")
	debug8 = debug(|\"8 \")
	debug9 = debug(|\"9 \")

	debuga = debug(|\"a \")
	debugb = debug(|\"b \")
	debugc = debug(|\"c \")
	debugd = debug(|\"d \")
	debuge = debug(|\"e \")
	debugf = debug(|\"f \")
	debugg = debug(|\"g \")
	debugh = debug(|\"h \")
	debugi = debug(|\"i \")
	debugj = debug(|\"j \")
	debugk = debug(|\"k \")
	debugl = debug(|\"l \")
	debugm = debug(|\"m \")
	debugn = debug(|\"n \")
	debugo = debug(|\"o \")
	debugp = debug(|\"p \")
	debugq = debug(|\"q \")
	debugr = debug(|\"r \")
	debugs = debug(|\"s \")
	debugt = debug(|\"t \")
	debugu = debug(|\"u \")
	debugv = debug(|\"v \")
	debugw = debug(|\"w \")
	debugx = debug(|\"x \")
	debugy = debug(|\"y \")
	debugz = debug(|\"z \")

	
	pp-aterm = pp-aterm-box; box2text-string(|80)
	ppdebug(|t) = where(pp-aterm; debug(!t))

	ppdebug0 = ppdebug(|\"0 \")
	ppdebug1 = ppdebug(|\"1 \")
	ppdebug2 = ppdebug(|\"2 \")
	ppdebug3 = ppdebug(|\"3 \")
	ppdebug4 = ppdebug(|\"4 \")
	ppdebug5 = ppdebug(|\"5 \")
	ppdebug6 = ppdebug(|\"6 \")
	ppdebug7 = ppdebug(|\"7 \")
	ppdebug8 = ppdebug(|\"8 \")
	ppdebug9 = ppdebug(|\"9 \")
	
	ppdebuga = ppdebug(|\"a \")
	ppdebugb = ppdebug(|\"b \")
	ppdebugc = ppdebug(|\"c \")
	ppdebugd = ppdebug(|\"d \")
	ppdebuge = ppdebug(|\"e \")
	ppdebugf = ppdebug(|\"f \")
	ppdebugg = ppdebug(|\"g \")
	ppdebugh = ppdebug(|\"h \")
	ppdebugi = ppdebug(|\"i \")
	ppdebugj = ppdebug(|\"j \")
	ppdebugk = ppdebug(|\"k \")
	ppdebugl = ppdebug(|\"l \")
	ppdebugm = ppdebug(|\"m \")
	ppdebugn = ppdebug(|\"n \")
	ppdebugo = ppdebug(|\"o \")
	ppdebugp = ppdebug(|\"p \")
	ppdebugq = ppdebug(|\"q \")
	ppdebugr = ppdebug(|\"r \")
	ppdebugs = ppdebug(|\"s \")
	ppdebugt = ppdebug(|\"t \")
	ppdebugu = ppdebug(|\"u \")
	ppdebugv = ppdebug(|\"v \")
	ppdebugw = ppdebug(|\"w \")
	ppdebugx = ppdebug(|\"x \")
	ppdebugy = ppdebug(|\"y \")
	ppdebugz = ppdebug(|\"z \")
	
	
	ppdebugna(|t) = where(strip-annos; pp-aterm; debug(!t))

	ppdebugna0 = ppdebugna(|\"0 \")
	ppdebugna1 = ppdebugna(|\"1 \")
	ppdebugna2 = ppdebugna(|\"2 \")
	ppdebugna3 = ppdebugna(|\"3 \")
	ppdebugna4 = ppdebugna(|\"4 \")
	ppdebugna5 = ppdebugna(|\"5 \")
	ppdebugna6 = ppdebugna(|\"6 \")
	ppdebugna7 = ppdebugna(|\"7 \")
	ppdebugna8 = ppdebugna(|\"8 \")
	ppdebugna9 = ppdebugna(|\"9 \")
	
	ppdebugnaa = ppdebugna(|\"a \")
	ppdebugnab = ppdebugna(|\"b \")
	ppdebugnac = ppdebugna(|\"c \")
	ppdebugnad = ppdebugna(|\"d \")
	ppdebugnae = ppdebugna(|\"e \")
	ppdebugnaf = ppdebugna(|\"f \")
	ppdebugnag = ppdebugna(|\"g \")
	ppdebugnah = ppdebugna(|\"h \")
	ppdebugnai = ppdebugna(|\"i \")
	ppdebugnaj = ppdebugna(|\"j \")
	ppdebugnak = ppdebugna(|\"k \")
	ppdebugnal = ppdebugna(|\"l \")
	ppdebugnam = ppdebugna(|\"m \")
	ppdebugnan = ppdebugna(|\"n \")
	ppdebugnao = ppdebugna(|\"o \")
	ppdebugnap = ppdebugna(|\"p \")
	ppdebugnaq = ppdebugna(|\"q \")
	ppdebugnar = ppdebugna(|\"r \")
	ppdebugnas = ppdebugna(|\"s \")
	ppdebugnat = ppdebugna(|\"t \")
	ppdebugnau = ppdebugna(|\"u \")
	ppdebugnav = ppdebugna(|\"v \")
	ppdebugnaw = ppdebugna(|\"w \")
	ppdebugnax = ppdebugna(|\"x \")
	ppdebugnay = ppdebugna(|\"y \")
	ppdebugnaz = ppdebugna(|\"z \")

"

	create-properties-collect = 
		<output-text-file(|["lib", "runtime", "properties"], "collect.str")>
"module runtime/properties/collect

imports 
	
	runtime/properties/entries
	runtime/properties/tasks
	runtime/properties/interface
	runtime/properties/query
	runtime/properties/debug
  runtime/task/core
  runtime/task/create
  runtime/task/messages
  runtime/task/tasks
  runtime/nabl/collect
  runtime/nabl/uri
  runtime/nabl/tasks
  runtime/nabl/utils
  runtime/editor/origins
  runtime/editor/annotations
  runtime/types/collect
  
signature
  
  sorts
  
    Property
    
  constructors
    
    Prop : Property * Value * List(Dependency) -> Prop

rules // generic analysis of properties
  
  // call back to generic analysis
  nabl-store-props(|partition, prop*):
  	name -> name
  	where
  	  uri := <nabl-collect-def; nabl-uri> name
	  ; <map(nabl-store-prop(|partition, uri, name))> prop*
	
	nabl-store-prop(|partition, prop):
		name -> name
		where
      uri := <nabl-collect-def; nabl-uri> name
    ; <nabl-store-prop(|partition, uri, name)> prop
      
  nabl-store-prop(|partition, uri, name):
    Prop(kind, prop, dep*) -> <new-prop(|partition, uri, kind, task)> name
    where
    	task := <task-create-id(|partition, <dependent-tasks> dep*)> prop
      
rules
        
  nabl-collect-custom-properties =
    iset := <new-iset>
  ; try(nabl-custom-properties(\\p* -> <iset-addlist(|p*); fail> iset\\))
  ; <iset-elements> iset
    
  nabl-get-all-properties = ![Type()|<nabl-collect-custom-properties>]
  
  // generic collection of property tasks
  nabl-annotate-properties(|lang, partition, old-uri*, new-uri*):
  	term -> term'
  	where
      kind* := <nabl-get-all-properties>
    ; term' := <foldl(nabl-annotate-property(|lang, partition, old-uri*, new-uri*) <+ Snd)> (kind*, term)
    ; try(nabl-constraint(|lang, partition, old-uri*, new-uri*))
  
  nabl-annotate-property(|lang, partition, old-uri*, new-uri*):
    (kind, term{a*}) -> term{(kind, prop), a*}
    where
      not(<get-property-task(|kind)> term)
    ; prop := <create-property-task(|partition, kind, old-uri*, new-uri*) <+ create-property-task(|partition, kind, new-uri*) <+ create-property-task(|partition, kind)> term
      
strategies
  
  nabl-prop-calc(|partition, dep*):
  	term -> <task-create-id(|partition, dep*)> term
  
  nabl-prop-list(|partition, dep*):
  	term -> <task-create-combine(|partition, dep*)> term
	
  nabl-prop-lookup(|kind, partition, dep*):
  	term -> result
  	with
      result := <get-annos; fetch-elem(?(kind, <id>))> term
      <+ 
			result := <nabl-create-collectdefs(|partition, dep*); prop-create-lookup(|partition, kind)> term
  
  nabl-prop-match(|kind, partition, relation, expected):
  	actual -> <task-create-choice(|partition)> check*
  	with 
		  expected* := <try-make-list> expected
		; check*    := <map(prop-create-check(|partition, kind, relation, actual))> expected*

rules
  
  get-or-create-property-task(|ctx, kind, old-uri*, new-uri*):
  	term -> task
  	where
  		(
         get-property-task(|kind)
      <+ create-property-task(|ctx, kind, old-uri*, new-uri*)
      <+ create-property-task(|ctx, kind, new-uri*)
      <+ create-property-task(|ctx, kind)
      <+ cannot-create-property-task(|ctx, kind)
      ) => task
  
  get-or-create-property-task(|ctx, kind):
  	term -> task
  	where
  		( 
          get-property-task(|kind)
      <+ (create-property-task(|ctx, kind, [], []); uris-not-passed(|ctx, kind))  
      <+ (create-property-task(|ctx, kind, []);     uris-not-passed(|ctx, kind))
      <+  create-property-task(|ctx, kind)
      <+  cannot-create-property-task(|ctx, kind)
      ) => task
      
  uris-not-passed(|ctx, kind):
  	term -> <properties-warning-task(|ctx, msg); properties-console-msg(|msg)> term
  	where
  		msg := $[Called create-property-task for property [<get-constructor> kind] on term [<write-to-string> term] that accepts uris with empty lists instead, because uris were not passed!]
      
  cannot-create-property-task(|ctx, kind):
  	term -> <properties-warning-task(|ctx, msg); properties-console-msg(|msg)> term
  	where
  		msg := $[Could not create task for property [<get-constructor> kind] on term [<write-to-string> term].]
      
  create-property-task(|ctx, kind):
    r@Result(_) -> <prop-create-extract(|ctx, kind)> r
    
  create-property-task(|ctx, kind) :
    term -> <nabl-prop-calc(|ctx, type*)> type*
    where 
    	type* := <map(get-property-task(|kind) <+ create-property-task(|ctx, kind))> term
    
rules
  
  remove-property-annotations(|kind*):
  	term -> <foldl(remove-property-annotation)> (kind*, term)
    
  remove-property-annotation:
    (kind, term) -> <remove-annotations(?(kind, _))> term

"

	create-properties-debug = 
		<output-text-file(|["lib", "runtime", "properties"], "debug.str")>
"module runtime/properties/debug

imports
	
	runtime/task/messages
	runtime/task/tasks
	runtime/nabl/utils
	
rules
	
	properties-console-msg-enable = fail
	properties-console-msg(|msg) = where(try(properties-console-msg-enable; err-msg(|msg)))
	
	properties-warning-task-disable = fail
	properties-warning-task(|ctx, msg):
		term -> <task-create-fail(|ctx)>
		where
			<properties-warning-task-disable <+ task-create-warning(|ctx, msg)> term

"

	create-properties-entries = 
		<output-text-file(|["lib", "runtime", "properties"], "entries.str")>
"module runtime/properties/entries

imports
  
  runtime/nabl/collect
  runtime/nabl/utils
  runtime/nabl/uri
  runtime/index/core
  runtime/editor/origins
  
signature

  constructors
    
    Prop  : URI * Property * Value -> Entry

rules // Index entries to diff for incrementality
  
  nabl-diff-entry = ?Prop(_, _, _)

rules
  
	new-prop(|partition, uri, kind, val):
		x -> prop
		with
			prop := <origin-track-forced(!Prop(uri, kind, val))> x;
			<index-add(|partition)> prop
	      
rules // index uri & value projections
  
  /** @internal */  
  nabl-uri:
    Prop(uri, _, _) -> uri
    
  /** @internal */  
  nabl-uris:
    Prop(uri, _, _) -> [uri]
    
  /** @internal */
  nabl-value:
    Prop(_, _, value) -> value
    
  /** @internal */
  nabl-values:
    Prop(_, _, value) -> [value]

"

	create-properties-eq = 
		<output-text-file(|["lib", "runtime", "properties"], "eq.str")>
"module runtime/properties/eq

signature constructors
  
  Eq: Relation
  
strategies
  
  nabl-reflexive = ?Eq()
  
  nabl-property-eq:
    (_, rel, p) -> <where(strip-annos; eq); Fst> p
    where
      <nabl-reflexive> rel
  
  nabl-property-eq(|kind, rel, expected):
  	actual -> <nabl-property-eq> (kind, rel, (actual, expected))

"

	create-properties-interface = 
		<output-text-file(|["lib", "runtime", "properties"], "interface.str")>
"module runtime/properties/interface

strategies // implementations generated from NaBL
  
  nabl-custom-properties(add-properties) = fail
  
  create-property-task(|ctx, kind) = fail
  
  create-property-task(|ctx, kind, uri*) = fail

  create-property-task(|ctx, kind, old-uri*, new-uri*) = fail

strategies // user-defined implementations
	
	nabl-constraint(|lang, partition, old-uri*, new-uri*) = nabl-constraint(|lang, partition, new-uri*)

  nabl-constraint(|lang, partition, uri*) = nabl-constraint(|partition)

	nabl-constraint(|partition) = fail

	nabl-property-eq = fail
	
"

	create-properties-query = 
		<output-text-file(|["lib", "runtime", "properties"], "query.str")>
"module runtime/properties/query

imports
	runtime/nabl/query
	runtime/nabl/uri
	runtime/task/core
	runtime/properties/entries
  runtime/properties/tasks
  runtime/properties/interface
  runtime/nabl/interface
  runtime/editor/annotations

rules

  get-property-task(|kind) =
     map(get-property-task(|kind))
  <+ get-annos
   ; fetch-elem(?(kind, <id>))
    
rules
  
  get-property(|kind) =
    (get-property-task(|kind) <+ try(nabl-get-name); get-index-property(|kind))
  ; try(task-result-combinations-single; Hd) // Try because results may already be inserted? 
	
  get-properties(|kind) =
    (get-property-task(|kind) <+ try(nabl-get-name); get-index-properties(|kind))
  ; try(task-result-combinations-single; concat)
	
  get-index-property(|kind) =
    nabl-uris // TODO: how to handle multiple values?
  ; fetch-elem(!Prop(<id>, kind, ()); nabl-get-value)
   
  get-index-properties(|kind) =
    nabl-uris // TODO: how to handle multiple values?
  ; mapconcat(!Prop(<id>, kind, ()); nabl-get-all-values)

rules
	
	property-remove-all = topdown(try(remove-annotations(?(_, _))))

"

	create-properties-tasks = 
		<output-text-file(|["lib", "runtime", "properties"], "tasks.str")>
"module runtime/properties/tasks

imports 
	
	runtime/nabl/incremental
	runtime/nabl/uri
	runtime/properties/query
	runtime/properties/eq
  runtime/task/core
  runtime/task/create
  runtime/editor/annotations

signature
  
  constructors

    PropsLookup : Property * URI                    -> Instruction
    PropCheck   : Property * Relation * Term * Term -> Instruction
    PropExtract : Property * Term                   -> Instruction
    
rules

	prop-create-lookup(|ctx, kind):
		contains-uri -> <new-task(|ctx)> PropsLookup(kind, contains-uri)

  perform-task(|n):
  	PropsLookup(kind, contains-uri) -> res
		where
  	  uri := <nabl-uri> contains-uri
  	; <nabl-add-uri-read(|n)> uri
  	; val := <get-index-properties(|kind)> uri
  	; res := <try(concat)> val
		  // TODO: why try concat?
    
  perform-cyclic-task(|n):
  	PropsLookup(kind, contains-uri) -> res
  	where
  	  uri := <nabl-uri> contains-uri
  	; <nabl-add-uri-read(|n)> uri
  	; val := <get-index-properties(|kind)> uri
		; res := <try(concat); make-set> val
		  // TODO: why try concat?

rules
	
	prop-create-check(|ctx, kind, rel, actual):
		expected -> <new-task(|ctx)> PropCheck(kind, rel, actual, expected)
	
  perform-task(|n): 
  	PropCheck(kind, rel, actual, expected) -> [<nabl-property-eq> (kind, rel, (actual, expected))]

rules

	prop-create-extract(|ctx, kind):
		term -> <new-task(|ctx)> PropExtract(kind, term)

  perform-task(|n):
    PropExtract(kind, term) -> <get-annotation(?(kind, <id>))> term

"

	create-relations-entries = 
		<output-text-file(|["lib", "runtime", "relations"], "entries.str")>
"module runtime/relations/entries

imports
	
	runtime/relations/entries
	runtime/relations/interface
	runtime/relations/tasks
	runtime/index/core
	runtime/properties/query
	runtime/nabl/resolve
	runtime/nabl/entries
	runtime/nabl/utils
	runtime/task/core
	runtime/task/insert
	runtime/task/utils
	runtime/editor/origins
	
signature

  constructors
    
    RelTuple   : Term * Relation * Term -> Entry
    Inverse    : Relation -> Relation
    Transitive : Relation -> Relation 
 
rules
  
  new-rel-tuple(|partition, rel, t2):
    t1 -> tuple
    with
      relation-ensure-no-task-reference
    ; t1' := <relation-try-term-to-uri> t1
    with
      tuple := <origin-track-forced(!RelTuple(t1', rel, t2))> t1
    ; <index-add(|partition)> tuple
    ; if <relation-is-transitive> rel then
	      task       := <relation-create-lookup(|partition, rel)> t2
	    ; transitive := <origin-track-forced(!RelTuple(t1', Transitive(rel), task))> t1
	    ; <index-add(|partition)> transitive
    end

rules
	
	relation-ensure-no-task-reference = 
		with(not(collect-one-annos(relation-is-unresolved-use))|$[Cannot create a relation tuple with a reference to a resolution task on the left hand side.]) 

	relation-try-term-to-uri:
		term -> result
		where
			if use := <collect-one-annos(relation-is-unresolved-use)> term then
				result := <relation-resolve-use> use
			else
				result := <try(collect-one-annos(relation-get-uri))> term
			end
		
	relation-get-uri:
		Def(uri) -> uri
		
	relation-get-uri:
		Use(Def(uri)) -> uri
		
	relation-is-unresolved-use =
		?Use(Result(_))
		
	relation-resolve-use:
		Use(r@Result(_)) -> <insert-results-or-delay; Hd; nabl-uri> r
		
rules
	
	relation-tuple-key:
		RelTuple(key, _, _) -> key

"

	create-relations-incremental = 
		<output-text-file(|["lib", "runtime", "relations"], "incremental.str")>
"module runtime/relations/incremental

imports
	
	runtime/relations/entries
	runtime/nabl/uri
	runtime/nabl/incremental
	runtime/task/core
	
rules
	
	relation-add-read(|task-id) = (nabl-is-uri; nabl-add-uri-read(|task-id)) <+ task-add-read(|task-id) 

rules
	
	relation-get-changed-reads:
		changed-entry* -> read-term*
		with
		  read-term* := <filter(relation-tuple-key); map(try(nabl-replace-uri-qualifier(|())))> changed-entry*

"

	create-relations-interface = 
		<output-text-file(|["lib", "runtime", "relations"], "interface.str")>
"module runtime/relations/interface

strategies
  
  /** 
   * Interface for static relation tuples, e.g. 
   * relation-store-value(store): (SubType(), IntTy()) -> <store> FloatTy()
   */
  relation-store-value(store) = fail
  /** 
   * Interface for static relation tuples, e.g. 
   * relation-match-tuple = ?(SubType(), IntTy(), FloatTy())
   */
  relation-match-tuple = fail
  /** 
   * Interface for custom relations, e.g.
   * relation-match-custom(|ctx): (SubType(), IntTy(), FloatTy()) -> task
   */
  relation-match-custom(|ctx) = fail
  
  relation-is-transitive = fail
  relation-is-reflexive  = fail
  relation-is-symmetric  = fail
  
"

	create-relations-query = 
		<output-text-file(|["lib", "runtime", "relations"], "query.str")>
"module runtime/relations/query

imports
	
  runtime/relations/entries
  runtime/relations/interface
  runtime/index/query
  runtime/task/insert
  
rules // Lookup relation values for given term
	
	relation-lookup(|rel):
		term -> <map(relation-try-term-to-uri)> [refl-val*, val*]
		where
		  refl-val* := <(relation-is-reflexive; ![term]) <+ ![]> rel;
			(
				val* := <relation-lookup-internal(|rel); where(Hd)> term <+
			  val* := <relation-try-term-to-uri; relation-lookup-internal(|rel)> term
		  )

	relation-lookup-internal(|rel):
		term -> [stat-val*, val*, trans-val*]
		where
		  stat-val*  := <get-static-relations(|rel)> term
		; val*       := <get-index-relations(|rel)> term
	  ; trans-val* := <(relation-is-transitive; <get-index-relations-transitive(|rel)> term) <+ ![]> rel
		// TODO: what about symmetric relations?
		
rules // Check if relation exists between two terms
	
	relation-match(|rel, expected):
		actual -> expected
		where
      <zip(relation-match-internal(|rel)) <+ relation-match-internal(|rel)> (actual, expected)
	
	relation-match-internal(|rel):
		(actual, expected) -> expected
		where
			<relation-match-internal-match(|rel)> (actual, expected) <+
			<where(<relation-is-symmetric> rel); relation-match-internal-match(|rel)> (expected, actual) <+
			(
			  actual'   := <relation-try-term-to-uri> actual
      ; expected' := <relation-try-term-to-uri> expected
			; (
			  	<relation-match-internal-match(|rel)> (actual', expected') <+
			    <where(<relation-is-symmetric> rel); relation-match-internal-match(|rel)> (expected', actual')
			  )
			)
			
  relation-match-internal-match(|rel):
  	(actual, expected) -> <relation-match-tuple> (rel, actual, expected)
  	// TODO: can this be transtive?
  	
	relation-match-internal-match(|rel):
  	(actual, expected) -> <id>
  	where
  	  <get-index-relations(|rel); fetch(relation-try-term-to-uri; ?expected)> actual <+ 
		  <where(<relation-is-transitive> rel); get-index-relations-transitive(|rel); fetch(relation-try-term-to-uri; ?expected)> actual

rules /** @internal */
  
  get-index-relations(|rel):
    term -> <index-get-all; relation-get-all-values> RelTuple(term, rel, ())
  		
	get-index-relations-transitive(|rel):
		term -> <index-get-all; relation-get-all-values> RelTuple(term, Transitive(rel), ()) 
  		
	relation-tuple-value:
		RelTuple(_, _, v) -> v
		
	relation-get-all-values = mapconcat(relation-tuple-value; insert-results-or-delay; (is-list <+ MkSingleton))

rules /** @internal */

  get-static-relations(|rel):
  	t -> val*
  	with
      stat-set := <new-iset>
    ; <try(relation-store-value(store-tuple(|stat-set)))> (rel, t)
    ; val* := <iset-elements> stat-set
      
  store-tuple(|set): elem -> <fail> with <iset-add(|elem)> set

"

	create-relations-tasks = 
		<output-text-file(|["lib", "runtime", "relations"], "tasks.str")>
"module runtime/relations/tasks

imports
	
	runtime/relations/entries
  runtime/relations/query
  runtime/relations/incremental
  runtime/relations/interface
  runtime/task/create
  runtime/task/tasks
  runtime/nabl/uri
  runtime/nabl/incremental
  runtime/nabl/utils
	
signature
  
  constructors

		RelationTerm     : Term -> Instruction
    RelationLookup   : Relation * Term -> Instruction
    RelationMatch    : List(Term) * Term -> Instruction
    RelationDistance : Relation * Term * Term -> Instruction

rules // URI conversion
	
	relation-create-term(|ctx):
		term -> <new-task(|ctx)> RelationTerm(term)
		
	perform-task(|task-id):
		RelationTerm(term) -> (term, term')
		where
	    term' := <relation-try-term-to-uri> term
		; <relation-add-read(|task-id)> term'
    
rules // Lookup (customised in Java to store its result in a hash set, for fast lookups)

	relation-create-lookup(|ctx, rel):
		term -> <task-create-insert(|ctx); task-create-combine(|ctx)> lookup-task
		with
		  term-task   := <relation-create-term(|ctx)> term
		; lookup-task := <new-task(|ctx)> RelationLookup(rel, term-task)

  perform-task(|task-id):
    RelationLookup(rel, (term, term')) -> result*
    where
		  result* := <relation-lookup(|rel)> term
		  // TODO: remove redundant relation-try-term-to-uri calls in relation-lookup, term' is already the correct term.
		  
  task-get-storage-type:
  	RelationLookup(_, _) -> <task-set-storage>
  
rules // Match (custom implementation in Java that uses the hash set from a lookup task for fast lookups)
	
  relation-create-match(|ctx):
  	(rel, actual, expected) -> <relation-create-match(|ctx, rel, expected)> actual

	relation-create-match(|ctx, rel, expected) = 
		relation-create-match(|ctx, rel, expected, [])

  relation-create-match(|ctx, rel, expected, dep*):
  	actual -> result
  	with 
  	  lookup-task := <relation-create-lookup(|ctx, rel)> actual
  	; term-task   := <relation-create-term(|ctx)> expected
    ; all-dep*    := <merge-dependencies(|dep*)> (rel, actual, expected, lookup-task, term-task)
  	; match-task  := <new-task(|ctx, all-dep*)> RelationMatch(lookup-task, term-task)
  	; if custom-task := <relation-match-custom(|ctx)> (rel, actual, expected) then
  	  	result := <task-create-choice(|ctx)> [custom-task, match-task]
  	  else
  	  	result := match-task
  	  end
  
  task-get-type:
  	RelationMatch(_, _) -> <task-raw-type>
  	  
  task-get-storage-type:
  	RelationMatch(_, _) -> <task-set-storage>
		  
rules // Distance
	
  relation-create-distance(|ctx, rel, values):
  	actual -> <new-task(|ctx)> RelationDistance(rel, actual, values)
	
	// Task needs to be a combinator because `expected*` needs to be queried like a list to find the distance.
	task-is-combinator = ?RelationDistance(_, _, _)
	
  perform-task(|task-id): 
  	RelationDistance(rel, actual, value*) -> [<get-index> (<try-remove-list; relation-try-term-to-uri> actual, <map(relation-try-term-to-uri)> value*)]
		// Remove list on `actual` because this task is a combinator and `actual` may only contain one element.

"

	create-task-core = 
		<output-text-file(|["lib", "runtime", "task"], "core.str")>
"module runtime/task/core

imports 
  
  runtime/task/create
  runtime/task/insert
  runtime/task/utils
  runtime/task/primitives
  runtime/task/interface
  runtime/nabl/entries
  runtime/nabl/utils
  
signature

  sorts
  
    Result Instruction
  
  constructors
    
    Result : TaskID -> Result
    
    HigherOrder     : Instruction * List(TaskID) -> EvaluationReturn
    HigherOrderFail : List(TaskID)               -> EvaluationReturn

rules // API
  
  // todo: add API documentation for each of these including types
	
	task-add-message(|taskID, message)                         = task-api-add-message(|taskID, message)
	task-add-task(|partition, dependencies, instruction, 
	               type, storage-type, short-circuit)          = task-api-add-task(|partition, dependencies, instruction, type, storage-type, short-circuit)
	task-add-read(|task-id)                                    = task-api-add-read(|task-id, <id>)
	task-clear-partition                                       = task-api-clear-partition(|<id>)
	task-delay                                                 = task-api-delay(|<id>)
	task-debug-info(|partition)                                = task-api-debug-info(|partition)
	task-evaluate-now                                          = task-api-evaluate-now(task-collect-result-ids-2, insert-results-hashmap, task-perform-task|<id>)
	task-evaluate-scheduled                                    = task-api-evaluate-scheduled(task-collect-result-ids-2, insert-results-hashmap, task-perform-task)
	task-get-dependencies                                      = task-api-get-dependencies(|<id>)
	task-get-messages(|partition)                              = task-api-get-messages(|partition)
	task-get-readers                                           = task-api-get-readers(|<id>)
	task-invalidate-task-reads(|changedRead*)                  = task-api-invalidate-task-reads(|changedRead*)
	task-merge                                                 = task-api-merge
	task-sources-of(|task-id-or-task-id*)                      = task-api-sources-of(|task-id-or-task-id*)
	task-persist                                               = task-api-persist
	task-pop                                                   = task-api-pop
	task-push                                                  = task-api-push
	task-recover                                               = task-api-recover
	task-reset                                                 = task-api-reset
	task-result-combinations                                   = task-api-result-combinations(task-collect-result-ids-2, insert-results-hashmap|<id>, 0)
	task-result-combinations-single                            = task-api-result-combinations(task-collect-result-ids-2, insert-results-hashmap|<id>, 1)
	task-setup(|project-path)                                  = task-api-setup(|project-path)
	task-setup                                                 = task-api-setup(|<id>)
	task-start-collection(|partition)                          = task-api-start-collection(|partition)
	task-stop-collection(|partition)                           = task-api-stop-collection(|partition)
	task-unload                                                = task-unload(|<id>)
	task-unload(|project-path)                                 = task-api-unload(|project-path)
	
	// Deprecated, use task-get-results
	task-get-result = task-get-results
	
	task-get-results =
		switch id
			case ?Result(taskID) : task-api-get-results(|taskID)
			otherwise            : task-api-get-results(|<id>)
		end
	
	task-has-failed =
		switch id
			case ?Result(taskID) : task-api-has-failed(|taskID)
			otherwise            : task-api-has-failed(|<id>)
		end
		
	task-get-solved =
		switch id
			case ?Result(taskID) : task-api-get-results(|taskID) <+ (task-api-has-failed(|taskID); ![])
			otherwise            : task-api-has-failed(|<id>) <+ (task-api-has-failed(|<id>); ![])
		end

rules // Projections
	
	task-result-id:
    Result(taskID) -> taskID

	task-collect-result-ids =
		collect-all-annos(task-result-id, union)
	
	task-use-result-id:
    Use(Result(taskID)) -> taskID
		
	task-collect-result-ids-2 =
		collect-all-annos-2(task-result-id, task-use-result-id, union)

rules // Execution
	
	task-perform-task(|task-id):
		instruction -> result
		where
			if <task-is-higherorder> instruction then
			  task-start-collection(|task-id)
			; if new-instruction := <perform-task(|task-id)> instruction then
					(_, added*) := <task-stop-collection(|task-id)>
				; result := HigherOrder(new-instruction, added*)
			  else
			    (_, added*) := <task-stop-collection(|task-id)>
			  ; result := HigherOrderFail(added*)
		  	end
			else
				result :=	<perform-task(|task-id)> instruction
			end

"

	create-task-create = 
		<output-text-file(|["lib", "runtime", "task"], "create.str")>
"module runtime/task/create

imports
	
	runtime/task/core
	runtime/task/interface

rules
	
	/**
	 * @type Partition * Instruction -> Result
	 */
  new-task(|partition) = new-task(|partition, <dependent-tasks>)

  /**
   * @type Partition * List(TaskID) * Instruction -> Result
   */  
  new-task(|partition, type, storage-type) = new-task(|partition, <dependent-tasks>, type, storage-type)

  /**
   * @type Partition * List(TaskID) * Instruction -> Result
   */  
  new-task(|partition, dependencies):
  	instruction -> result
  	with
  		type          := <determine-task-type> instruction;
  		storage-type  := <determine-task-storage-type> instruction;
			result        := <new-task(|partition, dependencies, type, storage-type)> instruction
  		
	new-task(|partition, dependencies, type, storage-type):
		instruction -> result
		with
  		short-circuit := <task-short-circuit; !1 <+ !0> instruction;
  		result        := <task-add-task(|partition, dependencies, instruction, type, storage-type, short-circuit)> instruction
  
  task-regular-type = !0
  task-combinator-type = !1
  task-raw-type = !2
  
  task-auto-storage = !0
  task-list-storage = !1
  task-set-storage = !2
  		
	determine-task-type = task-get-type <+ (task-is-combinator; task-combinator-type) <+ task-regular-type // Default to regular task
	determine-task-storage-type = task-get-storage-type <+ task-list-storage // Default to list storage
  		
	new-task-fixdeps(|partition, dependencies) = new-task(|partition, <dependent-tasks> dependencies)
      
  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
  dependent-task = ?Result(<id>) 
  dependent-task =
    has-annos; get-annos; dependent-tasks
    
	merge-dependencies(|dep*):
  	term -> <union> (<dependent-tasks> dep*, <dependent-tasks> term)
    
	task-create-execute-ctx = !\"\"
	task-create-execute(create-task):
		term -> result
		with
		  ctx := <task-create-execute-ctx>
		; task-push
		; task-start-collection(|ctx)
		; Result(taskID) := <create-task> term
		; task-stop-collection(|ctx)
		; <task-evaluate-now> taskID
		; result := <task-get-results> taskID
		; task-pop

"

	create-task-debug = 
		<output-text-file(|["lib", "runtime", "task"], "debug.str")>
"module runtime/task/debug

imports
	
	runtime/task/core
	runtime/task/create
	runtime/task/insert

signature

	constructors
		
		Debug : Term * Term -> Instruction

rules
	
	task-transitive-dependencies = task-transitive-dependencies(|[])
	
	task-transitive-dependencies(|seen):
		taskID -> [dep*, trans-dep*]
		where
			not(<elem> (taskID, seen));
			dep*       := <task-get-dependencies> taskID;
			trans-dep* := <mapconcat(task-transitive-dependencies(|[taskID|seen]))> dep*
			
	task-transitive-dependencies(|seen):
		taskID -> []
		where
			<elem> (taskID, seen)
			
rules
	
	task-debug-ast:
		ast -> debug*
		with
			resultID* := <task-collect-result-ids> ast;
			dep*      := <mapconcat(task-transitive-dependencies)> resultID*;
			debug*    := <make-set; map(task-debug-info(|<id>))> [resultID*, dep*]

rules
	
	task-debug(|ctx):
		term -> <new-task(|ctx)> Debug(\"\", term)
		
	task-debug(|ctx, prefix):
		term -> <new-task(|ctx)> Debug(prefix, term)
		
	task-is-combinator = ?Debug(_, _)

	perform-task(|task-id):
		Debug(prefix, term) -> term
		where
			switch !term
				case ?[]                            : <task-debug-msg(|task-id, prefix); fail> \"__FAIL__\"
				otherwise                           : <task-debug-msg(|task-id, prefix)> term
			end

	task-debug-msg(|task-id, prefix):
		msg -> <debug(!$[[task-id] - [prefix] ])> msg

"

	create-task-insert = 
		<output-text-file(|["lib", "runtime", "task"], "insert.str")>
"module runtime/task/insert

imports
	
	runtime/task/core

rules
	
	replace-results(list, result, fail-result, no-result) =
		switch id
			case has-annos  : ?t; !(<replace-results-noannos(list, result, fail-result, no-result)> t, <get-annos; replace-results(list, result, fail-result, no-result)> t); set-annos
			otherwise       : replace-results-noannos(list, result, fail-result, no-result)
		end		

	replace-results-noannos(list, result, fail-result, no-result) =
		switch id
			case is-list    : list
			case ?Result(n) : result <+ (task-has-failed; fail-result) <+ no-result 
			otherwise       : all(replace-results(list, result, fail-result, no-result))
		end
		
		
	insert-results-hashmap(|results-hashmap) =
		replace-results(
		  filter(insert-results-hashmap(|results-hashmap))
		, \\Result(n) -> <try(<hashtable-get(|n)> results-hashmap)>\\
		, id
		, id
	  )

	insert-results(fail-result, no-result) =
		replace-results(
		  map(insert-results(fail-result, no-result)) 
		, \\Result(n) -> <task-get-results>\\
		, fail-result
		, no-result	
		)
	
	// Inserts task results into given term.
	// Fails when dereferencing a task that has failed.
	// Delays the current evaluating task when dereferencing a task that has not been evaluated yet.
	insert-results-or-delay:
		term -> inserted
		where
			deps     := <new-iset>;
			inserted := <insert-results(![], \\Result(n) -> <iset-add(|n)> deps\\)> term;
			dep*     := <iset-elements> deps;
			if <gt> (<length> dep*, 0) then
				<task-delay> dep*
			end

"

	create-task-interface = 
		<output-text-file(|["lib", "runtime", "task"], "interface.str")>
"module runtime/task/interface

strategies
  
  perform-task(|task-id) = fail
  avoid-task(|dep*)      = fail
  
  task-get-type          = fail
  task-get-storage-type  = fail
  task-is-combinator     = fail // Deprecated, use task-get-type = task-combinator-type
  task-short-circuit     = fail
  task-is-higherorder    = fail
  
  task-rewrite           = fail
  task-match             = fail 
"

	create-task-messages = 
		<output-text-file(|["lib", "runtime", "task"], "messages.str")>
"module runtime/task/messages

imports
	
	runtime/task/core
	runtime/task/create
	runtime/editor/origins
	
signature

	sorts
	
		Message
		MessageTrigger
		
	constructors
		
    Error   : Origin * Term * Msg -> Message
    Warning : Origin * Term * Msg -> Message
    Note    : Origin * Term * Msg -> Message
    
    Always   : MessageTrigger // Always
    Failure  : MessageTrigger // No results
    Success  : MessageTrigger // At least one result
    Multiple : MessageTrigger // More than one result

    Message  : Result * List(Result) * MessageTrigger * Term -> Instruction

overlays
  
  MISSING_ORIGIN = \"MISSING ORIGIN INFORMATION\"

rules // message creation
	
	task-error-message(|message):
		term -> Error(<task-message-origin-location-offset> term, term, message)
		
	task-warning-message(|message):
    term -> Warning(<task-message-origin-location-offset> term, term, message)
    
	task-note-message(|message):
    term -> Note(<task-message-origin-location-offset> term, term, message)

rules // querying
	
	task-message:
		Error(_, _, message) -> message

	task-message:
		Warning(_, _, message) -> message
		
	task-message:
		Note(_, _, message) -> message


	task-message-term:
		Error(_, term, _) -> term

	task-message-term:
		Warning(_, term, _) -> term
		
	task-message-term:
		Note(_, term, _) -> term
		

	task-message-origin:
		Error(origin, _, _) -> origin

	task-message-origin:
		Warning(origin, _, _) -> origin
		
	task-message-origin:
		Note(origin, _, _) -> origin
	
rules // task creation
	
	task-create-message(|partition, exclude*):
    message -> <new-task(|partition)> Message((), exclude*, Always(), message)
  
  task-create-error(|partition, exclude*, message) = 
  	task-error-message(|message); task-create-message(|partition, exclude*)
	task-create-error(|partition, message) = 
  	task-create-error(|partition, [], message)
  		
	task-create-warning(|partition, exclude*, message) =
		task-warning-message(|message); task-create-message(|partition, exclude*)
	task-create-warning(|partition, message) =
		task-create-warning(|partition, [], message)
		
	task-create-note(|partition, exclude*, message) =
		task-note-message(|message); task-create-message(|partition, exclude*)
	task-create-note(|partition, message) =
		task-create-note(|partition, [], message)	
	
	
	task-create-message-on-failure(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Failure(), message)
  
  task-create-error-on-failure(|partition, task, exclude*, message) = 
  	task-error-message(|message); task-create-message-on-failure(|partition, task, exclude*)
	task-create-error-on-failure(|partition, task, message) = 
  	task-create-error-on-failure(|partition, task, [], message)
  		
	task-create-warning-on-failure(|partition, task, exclude*, message) =
		task-warning-message(|message); task-create-message-on-failure(|partition, task, exclude*)
	task-create-warning-on-failure(|partition, task, message) =
		task-create-warning-on-failure(|partition, task, [], message)
		
	task-create-note-on-failure(|partition, task, exclude*, message) =
		task-note-message(|message); task-create-message-on-failure(|partition, task, exclude*)
	task-create-note-on-failure(|partition, task, message) =
		task-create-note-on-failure(|partition, task, [], message)		
			
			
	task-create-message-on-success(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Success(), message)
  
  task-create-error-on-success(|partition, task, exclude*, message) = 
  	task-error-message(|message); task-create-message-on-success(|partition, task, exclude*)
	task-create-error-on-success(|partition, task, message) = 
		task-create-error-on-success(|partition, task, [], message)
		
	task-create-warning-on-success(|partition, task, exclude*, message) =
		task-warning-message(|message); task-create-message-on-success(|partition, task, exclude*)
	task-create-warning-on-success(|partition, task, message) =
		task-create-warning-on-success(|partition, task, [], message)
		
	task-create-note-on-success(|partition, task, exclude*, message) =
		task-note-message(|message); task-create-message-on-success(|partition, task, exclude*)
	task-create-note-on-success(|partition, task, message) =
		task-create-note-on-success(|partition, task, [], message)
		
		
	task-create-message-on-multiple(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Multiple(), message)
  
  task-create-error-on-multiple(|partition, task, exclude*, message) = 
  	task-error-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
	task-create-error-on-multiple(|partition, task, message) =
		task-create-error-on-multiple(|partition, task, [], message)
		
	task-create-warning-on-multiple(|partition, task, exclude*, message) =
		task-warning-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
	task-create-warning-on-multiple(|partition, task, message) =
		task-create-warning-on-multiple(|partition, task, [], message)
		
	task-create-note-on-multiple(|partition, task, exclude*, message) =
		task-note-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
	task-create-note-on-multiple(|partition, task, message) =
		task-create-note-on-multiple(|partition, task, [], message)

rules // task execution
  
  task-is-combinator = ?Message(_, _, _, _)

  perform-task(|n):
    Message(task, exclude*, trigger, message) -> ()
    where
    	 // Use task-result-combinations to recursively insert into exclude tasks, to find out if they fail.
    	<map(not(?[]); task-result-combinations)> exclude*;
      switch !trigger
      	case ?Always()   : task-add-message(|n, message)
        case ?Failure()  : not(<Hd> task); task-add-message(|n, message)
        case ?Success()  : <Hd> task; task-add-message(|n, message)
        case ?Multiple() : <Tl; Hd> task; task-add-message(|n, message)
      end

rules
	
	task-message-origin-location-offset:
		term -> <origin-location-offset <+ MISSING_ORIGIN()> term
		where
		  not(<is-list> term)
		
  task-message-origin-location-offset:
    list -> location-offset
    where
      <is-list> list;
      (
      	(partition, line, column, start-offset, _) := <Hd; origin-location-offset> list;
      	(_, _, _, _, end-offset)                   := <last; origin-location-offset> list;
      	location-offset := (partition, line, column, start-offset, end-offset)
      ) <+
      	location-offset := MISSING_ORIGIN()

"

	create-task-new-messages = 
		<output-text-file(|["lib", "runtime", "task"], "new-messages.str")>
"module runtime/task/new-messages

imports
  
  runtime/task/core
  runtime/task/create
  runtime/editor/origins
  runtime/task/messages
  
signature

  sorts
  
    Message
    MessageTrigger
    
  constructors
    
    Error   : Origin * Term * Msg -> Message
    Warning : Origin * Term * Msg -> Message
    Note    : Origin * Term * Msg -> Message
    
    Failure  : List(Result) -> MessageTrigger // No results
    Success  : List(Result) -> MessageTrigger // At least one result
    Multiple : List(Result) -> MessageTrigger // More than one result

    Message  : MessageTrigger * Term -> Instruction

rules // task creation
  
  task-create-message-on-triggers(|partition, triggers):
    message -> <new-task(|partition)> Message(triggers, message)
  
  task-create-error-on-triggers(|partition, triggers, message) = 
    task-error-message(|message); task-create-message-on-triggers(|partition, triggers)
    
  task-create-warning-on-triggers(|partition, triggers, message) =
    task-warning-message(|message); task-create-message-on-triggers(|partition, triggers)
    
  task-create-note-on-triggers(|partition, triggers, message) =
    task-note-message(|message); task-create-message-on-triggers(|partition, triggers)
  
rules // task execution
  
  task-is-combinator = ?Message(_, _)

  perform-task(|n):
    Message(trigger*, message) -> []
    where
      <map(?Failure([]) + ?Success([_|_]) + ?Multiple([_, _|_]))> trigger*
    where
      task-add-message(|n, message)

"

	create-task-primitives = 
		<output-text-file(|["lib", "runtime", "task"], "primitives.str")>
"module runtime/task/primitives

rules /** @internal API primitives */

	task-api-add-message(|taskID, message) = prim(\"task_api_add_message\", taskID, message)
	task-api-add-read(|taskID, read) = prim(\"task_api_add_read\", taskID, read)
	task-api-add-task(|partition, dependencies, instruction, type, storage-type, short-circuit) = prim(\"task_api_add_task\", partition, dependencies, instruction, type, storage-type, short-circuit)
	task-api-clear-partition(|partition) = prim(\"task_api_clear_partition\", partition)
	task-api-delay(|dependencies) = prim(\"task_api_delay\", dependencies)
	task-api-debug-info(|partition) = prim(\"task_api_debug_info\", partition)
	task-api-evaluate-now(collect, insert, perform|taskIDs) = prim(\"task_api_evaluate_now\", collect, insert, perform|taskIDs)
	task-api-evaluate-scheduled(collect, insert, perform|) = prim(\"task_api_evaluate_scheduled\", collect, insert, perform|)
	task-api-get-dependencies(|taskID) = prim(\"task_api_get_dependencies\", taskID)
	task-api-get-messages(|partition) = prim(\"task_api_get_messages\", partition)
	task-api-get-readers(|uri) = prim(\"task_api_get_readers\", uri)
	task-api-get-results(|taskID) = prim(\"task_api_get_results\", taskID)
	task-api-has-failed(|taskID) = prim(\"task_api_has_failed\", taskID)
	task-api-invalidate-task-reads(|changedReads) = prim(\"task_api_invalidate_task_reads\", changedReads)
	task-api-merge = prim(\"task_api_merge\")
	task-api-sources-of(|task-id-or-task-ids) = prim(\"task_api_sources_of\", task-id-or-task-ids)
	task-api-persist = prim(\"task_api_persist\")
	task-api-pop = prim(\"task_api_pop\")
	task-api-push = prim(\"task_api_push\")
	task-api-recover = prim(\"task_api_recover\")
	task-api-reset = prim(\"task_api_reset\")
	task-api-result-combinations(collect-results, insert-results|term, single-level) = prim(\"task_api_result_combinations\", collect-results, insert-results|term, single-level)
	task-api-setup(|project-path) = prim(\"task_api_setup\", project-path)
	task-api-start-collection(|partition) = prim(\"task_api_start_collection\", partition)
	task-api-stop-collection(|partition) = prim(\"task_api_stop_collection\", partition)
	task-api-unload(|project-path) = prim(\"task_api_unload\", project-path)

"

	create-task-tasks = 
		<output-text-file(|["lib", "runtime", "task"], "tasks.str")>
"module runtime/task/tasks

imports
	
	runtime/task/core
	runtime/task/create
	runtime/task/insert
  runtime/task/messages
	runtime/task/interface
  
signature

	constructors
		
    Id       : Term                -> Instruction
    Fail     :                        Instruction
    Choice   : List(Result)        -> Instruction
    Sequence : List(Result)        -> Instruction
    Combine  : List(Result)        -> Instruction
    Singleton: Result              -> Instruction
    Diff     : Result * Result     -> Instruction
    Collect  : List(Result)        -> Instruction
    Not      : Result              -> Instruction
    Index    : Int * List(Result)  -> Instruction
    Length   : List(Result)        -> Instruction
    Sum      : List(Result)        -> Instruction
    Fetch    : Term * List(Result) -> Instruction
    Eq       : Term * Term         -> Instruction
    Insert   : Term                -> Instruction
    Rewrite  : ID * Result         -> Instruction
    MakeSet  : Term                -> Instruction 

rules
  
  /**
   * Create a task that produces its input term.
   *
   * @type Term -> Result
   */
	task-create-id(|ctx) =
	  ?Result(_) <+ <new-task(|ctx)> Id(<id>)

  /**
   * Create a task that produces its input term, where results are stored in a set.
   *
   * @type Term -> Result
   */	  
	task-create-set-id(|ctx) =
	  ?Result(_) <+ <new-task(|ctx, <task-regular-type>, <task-set-storage>)> Id(<id>)
  
  /**
   * Create a task that produces its input term, with extra static dependencies.
   *
   * @type Term -> Result
   */
  task-create-id(|ctx, dep*):
  	term -> <new-task(|ctx, all-dep*)> Id(term)
  	with 
    	all-dep* := <merge-dependencies(|dep*)> term
    	
  /**
   * Create a task that produces its input term, with extra dependencies, where results are stored in a set.
   *
   * @type Term -> Result
   */
  task-create-set-id(|ctx, dep*):
  	term -> <new-task(|ctx, all-dep*, <task-regular-type>, <task-set-storage>)> Id(term)
  	with 
    	all-dep* := <merge-dependencies(|dep*)> term
  
  
  /** @internal */
  perform-task(|task-id) = ?Id(<MkSingleton>)
  
rules
	
  /**
   * Create a task that always fails.
   *
   * @type _ -> Result
   */
	task-create-fail(|ctx):
		_ -> <new-task(|ctx)> Fail()
	
	
	/** @internal */	
	perform-task(|task-id):
		Fail() -> <fail>

rules
	
  /**
   * Create a task that produces the results of the first subtask that succeeds.
   *
   * @type List(Result) -> Result
   */
  task-create-choice(|ctx) =
     ?[<?Result(_)>] <+ <new-task(|ctx)> Choice(<id>)
  
  /**
   * Create a choice task between two tasks, where t1 and t2 take a ctx and produce a task.
   *
   * @type Term -> Result
   */
  task-create-choice(t1, t2|ctx):
    term -> <task-create-choice(|ctx)> [<t1(|ctx)> term, <t2(|ctx)> term]
	
	
	/** @internal */
	task-get-type: Choice(_) -> <task-combinator-type>
	/** @internal */
	task-get-storage-type: Choice(_) -> <task-auto-storage>
	/** @internal */
  perform-task(|task-id) = ?Choice(<fetch-elem(not(?[]))>)
  
rules
	
  /**
   * Create a task that only succeeds when all subtasks succeed, and produces the result of the last subtask.
   *
   * @type List(Result) -> Result
   */
  task-create-sequence(|ctx) =
    ?[<?Result(_)>] <+ <new-task(|ctx)> Sequence(<id>)

  /**
   * Create a sequence task between two tasks, where t1 and t2 take a ctx and produce a task.
   * @type (Result * Partition -> Result) * (Result * Partition -> Result) * Partition -> Result
   */
  task-create-sequence(t1, t2|ctx):
    term -> <task-create-sequence(|ctx)> [<t1(|ctx)> term, <t2(|ctx)> term]
	
	
	/** @internal */
	task-get-type: Sequence(_) -> <task-combinator-type>
	/** @internal */
	task-get-storage-type: Sequence(_) -> <task-auto-storage>
	/** @internal */
  perform-task(|task-id)  = ?Sequence(<not(fetch-elem(?[])); last>)

rules
       
  /**
   * Create a task that combines the results of all subtasks.
   * 
   * @type List(Result) -> Result
   */
	task-create-combine(|ctx) =
	  ?[<?Result(_)>] <+ <new-task(|ctx)> Combine(<id>)
	
  /**
   * Create a task that combines the results of all subtasks, with extra static dependencies.
   * 
   * @type List(Result) -> Result
   */	
	task-create-combine(|ctx, dep*):
		task* -> <new-task(|ctx, all-dep*)> Combine(task*)
  	with 
    	all-dep* := <merge-dependencies(|dep*)> task*


  /** @internal */
	task-get-type: Combine(_) -> <task-combinator-type>
	/** @internal */
	task-get-storage-type: Combine(_) -> <task-auto-storage>
	/** @internal */
  perform-task(|task-id)  = ?Combine(<mapconcat(is-list <+ MkSingleton)>)

rules
       
  /**
   * Creates a task that collects all results from its subtasks, and produces a single list with all collected results.
   *
   * @type List(Result) -> Result
   */
	task-create-collect(|ctx) = <new-task(|ctx)> Collect(<id>)


  /** @internal */
	task-get-type: Collect(_) -> <task-combinator-type>
	/** @internal */
  perform-task(|task-id)  = ?Collect(<mapconcat(is-list <+ MkSingleton)>); MkSingleton

rules
	
  /**
   * Creates a task that inserts task results into given term.
   *
   * @type Term -> Result
   */
	task-create-insert(|ctx):
		term -> <new-task(|ctx)> Insert(term)
	
	
	/** @internal */
	task-get-type: Insert(_) -> <task-combinator-type>
	/** @internal */
	task-get-storage-type: Insert(_) -> <task-auto-storage>
	/** @internal */
	perform-task(|task-id): Insert(term) -> <insert-results-or-delay> term

rules
  
  /**
   * Creates a task that only succeeds if its subtask produces exactly one result, and produces that result.
   *
   * @type Result -> Result
   */  
  task-create-singleton(|ctx) =
    <new-task(|ctx)> Singleton(<id>)
  
  
  /** @internal */
	task-get-type: Singleton(_) -> <task-combinator-type>
	/** @internal */
  perform-task(|task-id): Singleton(r@[_]) -> r
    
rules
  
  /**
   * Creates a task that takes the difference between two lists.
   *
   * @type List(Term) * List(Term) -> Result
   */
  task-create-diff(|ctx):
    (l1, l2) -> <new-task(|ctx)> Diff(l1, l2)
  
  /**
   * Creates a task that takes the difference between two lists, where the second list is passed as a term argument.
   *
   * @type List(Term) -> Result
   */
  task-create-diff(|ctx, l2):
    l1 -> <new-task(|ctx)> Diff(l1, l2)


  /** @internal */
	task-get-type: Diff(_, _) -> <task-combinator-type>
	/** @internal */
  perform-task(|task-id): Diff(l1, l2) -> <diff> (l1, <is-list <+ MkSingleton> l2)

rules
  
  // TODO: what does this do?
  task-create-where(s|ctx):
    term -> <task-create-sequence(|ctx)> <try(flatten-list)> [<s> term, term]

rules
  
  /**
   * Creates a negation task, that succeeds if it subtask fails, and vice versa.
   *
   * @type Result -> Result
   */
  task-create-not(|ctx) = <new-task(|ctx)> Not(<id>)
  
  /**
   * Create negation task, where t takes a ctx argument and produces the task to be negated 
   */
  task-create-not(t|ctx) = t(|ctx); task-create-not(|ctx)
  
  
  /** @internal */
	task-get-type: Not(_) -> <task-combinator-type>
	/** @internal */
  perform-task(|task-id): Not([]) -> ()
  
rules
  
  /**
   * Creates a task that produces the term at given index in a list.
   *
   * @type List(Term) -> Result
   */
  task-create-index(|ctx, i):
  	list -> <new-task(|ctx)> Index(i, list)
  
  
  /** @internal */
  perform-task(|task-id) = ?Index(i, <index(|i)>); MkSingleton
  
rules
	
  /**
   * Creates a task that produces the length of a list.
   *
   * @type List(Term) -> Result
   */
	task-create-length(|ctx):
		list -> <new-task(|ctx)> Length(list)
	
	
	/** @internal */
  perform-task(|task-id) = ?Length(<length>); MkSingleton

rules
	
  /**
   * Creates a task that produces the sum of the numbers in a list.
   *
   * @type List(INT <+ REAL) -> Result
   */
	task-create-sum(|ctx):
		list -> <new-task(|ctx)> Sum(list)
	
	
	/** @internal */
	perform-task(|task-id):
		Sum(list) -> <sum> list
		
rules
	
  /**
   * Creates a task that succeeds if the list contains the term.
   *
   * @type Term -> Result
   */
	task-create-fetch(|ctx, list):
		term -> <new-task(|ctx)> Fetch(term, list)
	
	
	/** @internal */
	perform-task(|task-id):
		Fetch(term, list) -> <fetch-elem(?term)> list
		
rules
	
  /**
   * Creates a task that succeeds if given terms are equal.
   *
   * @type Term -> Result
   */
	task-create-eq(|ctx, expected):
		actual -> <new-task(|ctx)> Eq(expected, actual)
		
		
  /** @internal */
	perform-task(|task-id):
		Eq(expected, actual) -> <eq; !actual> (expected, actual)

rules

  /**
   * Creates a task that converts the results of its subtask into set, removing all duplicates.
   *
   * @type Result -> Result
   */	
	task-create-make-set(|ctx):
		term -> <new-task(|ctx)> MakeSet(term)
		
		
	/** @internal */
	task-get-storage-type: MakeSet(_) -> <task-set-storage>
	/** @internal */
	perform-task(|task-id): MakeSet(term) -> term // Do nothing, task storage type takes care of conversion into set.		
  
rules
      	
  /**
   * Create task that performs a rewrite on its input term. It will perform the task-rewrite strategy with input
   * term (key, term), where the key is given as a strategy argument to this strategy.
   *
   * @type Term -> Result
   */
  task-create-rewrite(|ctx, key) = <new-task(|ctx)> Rewrite(key, <id>)
  
  
  /** @internal */    	
  perform-task(|nr) = ?Rewrite(key, term); <task-rewrite; MkSingleton> (key, term)
  
rules /** @internal Cyclic task evaluation */
	
	perform-cyclic-task(|nr) = fail
	
	perform-task(|nr):
		(instruction, \"cyclic\") -> <perform-cyclic-task(|nr) <+ perform-task(|nr)> instruction

"

	create-task-utils = 
		<output-text-file(|["lib", "runtime", "task"], "utils.str")>
"module runtime/task/utils

rules

	oncetd-annos(s) = s <+ has-annos; get-annos; one(oncetd-annos(s)) <+ one(oncetd-annos(s))
	
	collect-one-annos(s) = oncetd-annos(s; ?t); !t
	
  crush-annos(nul, sum, s) :
    _#(xs){a*} -> r2
    where
     r1 := <foldr(nul, sum, s)> xs;
     r2 := <foldr(!r1, sum, s)> a*

	collect-all-annos(s, un) =
		![<s> | <crush-annos(![], un, collect-all-annos(s, un))>]
	<+ crush-annos(![], un, collect-all-annos(s, un))





  crush-annos-2(nul, un, s, sa) :
    _#(xs){a*} -> r2
    where
     r1 := <foldr(nul, un, collect-all-annos-2(s, un))> xs;
     r2 := <foldr(!r1, un, collect-all-annos-2(sa, un))> a*
     
  crush-annos-2(nul, un, s) :
    _#(xs){a*} -> r2
    where
     r1 := <foldr(nul, un, collect-all-annos-2(s, un))> xs;
     r2 := <foldr(!r1, un, collect-all-annos-2(s, un))> a*

	collect-all-annos-2(s, sa, un) =
		![<s> | <crush-annos-2(![], un, s, sa)>]
	<+ crush-annos-2(![], un, s)

	collect-all-annos-2(s, un) =
		![<s> | <crush-annos-2(![], un, s)>]
	<+ crush-annos-2(![], un, s)
	
rules
	
	topdown-annos(s) =
		switch id
			case has-annos => t : !(<s; all(topdown-annos(s))> t, <get-annos; s; all(topdown-annos(s))> t); set-annos
			otherwise           : s; all(topdown-annos(s))
		end

"

	create-tmpl-pp = 
		<output-text-file(|["lib", "runtime", "tmpl"], "pp.str")>
"module runtime/tmpl/pp

imports
	
  libstratego-lib
  libstratego-gpp

signature constructors

  Parenthetical : Unknown -> Unknown

strategies

  // Unwrap Parenthetical/1 if pp fails, in case the user is using
  // parenthesize, but grammar does not contain {bracket} production.
  pp-one(pp) = (pp <+ ?Parenthetical(<pp>)); filter(gpp-is-real-vbox)

  pp-one-V(pp) = pp-one(pp); (?[] <+ !V([], <id>))
  pp-one-Z(pp) = pp-one(pp); (?[] <+ !Z([], <id>))

  pp-option(pp) = \\None() -> []\\ + ?Some(<pp>)

  pp-V-list(pp)    = ?[] <+ !V([], <map(pp-one-V(pp))>)
  pp-V-list(pp|vs) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp))>)
  pp-V-list(pp|vs, sep) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp)); at-init(add-sep(|sep), id)>)

  pp-indent(|is) = filter(gpp-is-real-vbox); (?[] <+ !I([SOpt(IS(), is)], H([SOpt(HS(), \"0\")], <id>)))

  pp-H-list(pp)     = ?[] <+ !H([], <map(pp-one-Z(pp))>)
  pp-H-list(pp|sep) = ?[] <+ !H([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

  pp-HV-list(pp)     = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
  pp-HV-list(pp|sep) = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

  pp-HZ-list(pp)     = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
  pp-HZ-list(pp|sep) = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

rules
  
 add-sep(|sep):
    V(vs, boxes) -> V(vs, result)
    where
    	if [h] := boxes
    	then
       	(c, [cs, inner-boxes]) := <explode-term> h;
        box-with-sep := <mkterm> (c, [cs, <conc> (inner-boxes, [S(sep)])]);
        result := [box-with-sep]
        else
        result' := [<last; add-sep(|sep)> boxes];
        result  := <at-last(!result')> boxes 
        end
        
 add-sep(|sep):
 	H(options, boxes) -> H(options, result)
 	where
    	result := <conc> (boxes, [S(sep)])
    	
 add-sep(|sep):
 	I(is, H(hs, boxes)) -> I(is, H(hs, result))
 	where
    	result := <conc> (boxes, [S(sep)])
    	
 add-sep(|sep):
 	HV(hs, boxes) -> HV(hs, result)
 	where
    	result := <conc> (boxes, [S(sep)])
    	
 add-sep(|sep):
 	HZ(hs, boxes) -> HV(hs, result)
 	where
    	result := <conc> (boxes, [S(sep)])

 add-sep(|sep):
 	Z(hs, boxes) -> HV(hs, result)
 	where
    	result := <conc> (boxes, [S(sep)])      
"

	create-types-collect = 
		<output-text-file(|["lib", "runtime", "types"], "collect.str")>
"module runtime/types/collect

imports 
	
	runtime/types/interface
	runtime/properties/collect
	runtime/properties/eq
  
signature

  constructors
    
    Type : Property
    
rules
  
  create-property-task(|ctx, kind, uri*) =
    where(Type() := kind)
  ; (create-type-task(|ctx, uri*) <+ create-type-task(|ctx))
       
  type-is(|partition)           = nabl-prop-calc(|partition, [])
  type-is(|partition, dep*)     = nabl-prop-calc(|partition, dep*)
  
  type-list(|partition)         = nabl-prop-list(|partition, [])
  type-list(|partition, dep*)   = nabl-prop-list(|partition, dep*)
  
  type-lookup(|partition)       = nabl-prop-lookup(|Type(), partition, [])
  type-lookup(|partition, dep*) = nabl-prop-lookup(|Type(), partition, dep*)

  type-match(|partition, expected)           = nabl-prop-match(|Type(), partition, Eq(), expected)
  type-match(|partition, relation, expected) = nabl-prop-match(|Type(), partition, relation, expected)
   
  store-type(|partition, type) = nabl-store-prop(|partition, Prop(Type(), type, []))
    
"

	create-types-interface = 
		<output-text-file(|["lib", "runtime", "types"], "interface.str")>
"module runtime/types/interface

imports
  
  runtime/types/collect
  
strategies // user-defined implementations
	
	create-type-task(|ctx) = fail
	
	create-type-task(|ctx, uri*) = fail

"

	create-types-query = 
		<output-text-file(|["lib", "runtime", "types"], "query.str")>
"module runtime/types/query

imports
  
  runtime/types/collect
  runtime/properties/collect
  runtime/properties/query
  
rules // during analysis
  
  type-task(|ctx) = get-or-create-property-task(|ctx, Type())
  type-task(|ctx, kind, old-uri*, new-uri*) = get-or-create-property-task(|ctx, Type(), old-uri*, new-uri*)
  get-type-task   = get-property-task(|Type())
  
rules // post analysis
  
  get-type = get-property(|Type())

"

create-all-runtime-libraries = 
	create-analysis-analysis
; 	create-analysis-builtins
; 	create-analysis-complete
; 	create-analysis-core
; 	create-analysis-debug
; 	create-analysis-defaults
; 	create-analysis-interface
; 	create-analysis-multiple
; 	create-analysis-reanalysis
; 	create-analysis-resolve
; 	create-analysis-single
; 	create-analysis-singleast
; 	create-editor-annotations
; 	create-editor-dynrule
; 	create-editor-eclipse
; 	create-editor-editor
; 	create-editor-interop
; 	create-editor-origins
; 	create-editor-outline-library
; 	create-editor-positions
; 	create-editor-properties
; 	create-editor-queue
; 	create-index-core
; 	create-index-globals
; 	create-index-legacy
; 	create-index-partition
; 	create-index-query
; 	create-index-utils
; 	create-modelware-model2tree
; 	create-modelware-modelware
; 	create-modelware-signatures
; 	create-modelware-tree2model
; 	create-nabl-check
; 	create-nabl-collect
; 	create-nabl-complete
; 	create-nabl-constraints
; 	create-nabl-entries
; 	create-nabl-incremental
; 	create-nabl-interface
; 	create-nabl-lookup
; 	create-nabl-namegen
; 	create-nabl-query
; 	create-nabl-resolve
; 	create-nabl-tasks
; 	create-nabl-uri
; 	create-nabl-utils
; 	create-properties-collect
; 	create-properties-debug
; 	create-properties-entries
; 	create-properties-eq
; 	create-properties-interface
; 	create-properties-query
; 	create-properties-tasks
; 	create-relations-entries
; 	create-relations-incremental
; 	create-relations-interface
; 	create-relations-query
; 	create-relations-tasks
; 	create-task-core
; 	create-task-create
; 	create-task-debug
; 	create-task-insert
; 	create-task-interface
; 	create-task-messages
; 	create-task-new-messages
; 	create-task-primitives
; 	create-task-tasks
; 	create-task-utils
; 	create-tmpl-pp
; 	create-types-collect
; 	create-types-interface
; 	create-types-query
